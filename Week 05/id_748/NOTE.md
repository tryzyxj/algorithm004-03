# 动态规划
* 动态规划（Dynamic programming，简称DP）。
* 动态规划的核心思想是把原问题分解成子问题进行求解，也就是分治的思想。

  

# 动态规划问题，大致可以通过以下四部进行解决。

1. 划分状态，即划分子问题，例如上面的例子，我们可以认为每个组下面、每个部门、每个中心下面最优秀的3个人，都是全公司最优秀的3个人的子问题

2. 状态表示，即如何让计算机理解子问题。上述例子，我们可以实用f[i][3]表示第i个人，他手下最优秀的3个人是谁。

3. 状态转移，即父问题是如何由子问题推导出来的。上述例子，每个人大Leader下面最优秀的人等于他下面的小Leader中最优秀的人中最优秀的几个。

4. 确定边界，确定初始状态是什么？最小的子问题？最终状态又是什么。例如上述问题，最小的子问题就是每个小组长下面最优秀的人，最终状态是整个企业，初始状态为每个领导下面都没有最优名单，但是小组长下面拥有每个人的评分。


# 实现方法

## 自底向上
简单来说就是根据初始状态，逐步推导到最终状态，而这个转移的过程，必定是一个拓扑序。如何理解这个拓扑序问题呢，甲总监下面有X,Y,Z两个小组，甲总监不会一拿到X组最优秀的三个人，就立马去跟A经理汇报，而是要等到Y,Z小组也选出来之后，也就是自己下面所有子问题都解决了，才会继续向汇报。如果推导的过程不是一个拓扑序，那么要么得到错误的结果，要么算法就要退化。

自底向上一般用来解决什么问题呢？那就是可以轻松确定拓扑序的问题，例如线性模型，都是从左往右进行转移，区间模型，一般都是从小区间推导到大区间。自底向上的一个经典实现是斐波那楔数列的递推实现，即F[i] = F[i - 1] + F[i - 2]。


## 自顶向下
也就是从最终状态出发，如果遇到一个子问题还未求解，那么就先求解子问题。如果子问题已经求解，那么直接使用子问题的解，所以自顶向下动态规划又有一个形象生动的名字，叫做记忆化搜索，一般我们采用递归的方式进行求解。

## 使用场景
自顶向下，我们一般用在树上面，因为我们根据父亲结点，很容易找到所有的子问题，也就是所有的子结点，而自底向上的话，我们要去统计这个结点的所有兄弟结点是否已经实现。会稍微复杂一点，而且比较难理解。

