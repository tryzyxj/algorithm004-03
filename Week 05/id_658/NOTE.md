# 第五周学习总结

## 动态规划

- 本质上将一个复杂的问题分解成各种简单的子问题，同时找问题的重复性
- 与递归、分治更多是一些细节上的不同，看有无最优子结构
- 分治+最优子结构
- 因为要找最优子结构（最大值、最优解、最少方式等等）所以可能需要记录每一步的最优值用来推导全局的最优值，所以存在缓存（状态的存储数组）以及每一步淘汰掉次优的状态

### 解析

1. 先进行递归分治，然后进行记忆化搜索再转化为自底向上的循环
2. 自底向上递推

    ```java
    a[0] = 0, a[i] = 1;
    for (int i = 2; i <= n; i++) {
        a[i] = a[i - 1] + a[i - 2]
    }
    ```

### 关键点

- 最优子结构 `opt[n] = best_of(opt[n - 1], opt[n - 2], ...)`
- 储存中间状态 `opt[i]`
- 递推公式（状态转移方程或者 DP 方程）
  - Fib: `opt[i] = opt[n - 1] + opt[n - 2]`
  - 二维路径: `opt[i][j] = opt[i + 1][j] + opt[i][j + 1]` 切判断 `a[i][j]` 是否为空地

## 小结

- 人肉递归低效且累
- 找到最近最简方法，将其拆解成可重复解决的问题
- 数学归纳法思维（抵制人肉递归的诱惑）
- 本质还是寻找重复性
- 打破自己的思维惯性，形成机器思维
- 理解复杂逻辑的关键
