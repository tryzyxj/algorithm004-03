# NOTE
#### 位运算

* 由来：计算机以二进制位存储方式
* 或 与 非 异或
* x ^ 0 = x
* x ^ 1 = ~x
* x ^ (~x) = 1
* x ^ x = 0
* c = a ^ b => a ^ c = b, b ^ c = a //交换两个数
* a ^ b ^ c = a ^ ( b ^ c) = ( a ^ b ) ^ c // associative

* 指定位置的位运算
    * 将x最右边的n位清零： x & ( ~0 << n)
    * 获取x的第n位值（0 或者 1）：（x >> n） & 1
    * 获取x的第n位的幂值：x&（1<<（n-1））
    * 仅将第n位置为1：x | （1 << n）
    * 仅将第n位置为0：x | （~1<<n）
    * 将x最高位至第n位(含）清零：x & ( (1 << n) - 1)
    * 将第n位至第0位（含）清零：x & （~((1<<(n+1)） -1 ))

#### 实战位运算要点

* 判断奇偶
    * x % 2 == 1 --> (x & 1) == 1
    * x % 2 == 0 --> (x & 1) == 0
* 除二
    * x >> 1 --> x/2
* x = x & (x - 1) 清零最低位的1
* x & -x =>得到最低位的1
* x & ~x =》0

#### 布隆过滤器（Bloom Filter vs HashTable）

* 一个很长的二进制向量和一系列随机映射函数。可以用于检索一个元素是否在一个集合中。
* 优点：空间效率远远高于一般的算法。
* 缺点：有一定的的误识别率和删除困难。
* 案例：
    * 1. 比特币网络
    * 2. 分布式系统（Map-Reduce） --Hadoop，search engine
    * 3. Redis缓存
    * 4. 垃圾邮件、评论等的过滤
#### LRU缓存，最近最少使用（Least Recently used）

* 两个要素：大小、**替换策略和推荐系统有异曲同工之处  **
* Hash Table + DoubleLinkedList
* O(1)查询
* O(1)修改，更新


#### Java LRU实现

#### 排序算法

* 初级排序和高级排序的实现和特性
    * 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogN)，因此也称为非线性时间比较类排序。可以通过comparable 或者 compartor等接口来实现类型比较。
    * 高级排序，重点看O(nlogN)：
        * 堆排序（Heap Sort，插入删除维护O(logN），取最大/最小值O（1）
            * 1：数组元素一次建立小顶堆
            * 2：一次取堆顶元素，并删除
        * 快速排序（Quick Sort使用了分治的思想）
            * 数组去标杆pivot，将小元素放pivot左边，大元素则放右侧，然后依次对右边和右边的子数组继续快排；以达到整个序列有序。
        * 归并排序（Merge Sort，使用了分治的思想，思路和快排相反）
            * 把长度为n的输入序列分成两个长度为n/2的子序列；
            * 对这两个子序列分别采用归并排序；
            * 将两个排序好的子序列合并成一个最终的排序序列。
        * 总结（归并和快排具有相似性，但步骤顺序相反）：
            * 归并：先排序左右子数组，然后合并两个有序子数组
            * 快排：先调配处左右子数组，然后对于左右子数组进行排序。
    * 初级排序（O(N^2)）
        * 选择排序：每次找最小值，然后放到待排序数组的起始位置。
        * 插入排序：从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
        * 冒泡排序（Bubble Sort）：嵌套循环，每次查看相邻的元素，如果逆序，则交换。
        
* 非比较类排序：
    *  不通过比较来决定元素间的相对次序，它可以突破基于比较排序时间下界，以线性时间运行，因此也称为线性时间非比较类排序，不过一般只能比较整数类型的。
        * 计数排序（Counting Sort，O(n））：计数排序要求输入的数据必须是在有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把技术大于1的填充回原数组。
        * 桶排序（Bucket Sort）计数排序的升级版；
        * 基数排序（Radix Sort）

 