# NOTE

### 第十六课 位运算的基础以及实战要点

#### 异或的一些相应的操作（有点类似于乘法分配律的感觉）：
1. x^0 = x			1011^0000 = 1011
2. x^1s = ~x		1011^1111 = 0100
3. x^(~x) = 1s		1011^0100 = 1111
4. x^x = 0			1011^1011 = 0
5. a^b = c --> a^c = b, b^c = a
6. a^b^c = a^(b^c) = (a^c)^b

#### 位运算常用技巧：
1. 判断奇偶：
x%2 == 1/0 ---> (x&1) == 1/0
2. 除二, 同理乘二
x/2 == x >> 1
3. 清零最低位1
x&(x-1)
4. 获取最低位1
x&(-x)
5. x&(~x) == 0

### 第十七课 布隆过滤器和LRU缓存

#### 布隆过滤器的原理和实现
1. 布隆过滤器的作用：
判断一个元素是否存在于集合中, 但是只能确定元素一定不在集合, 不能确定元素一定在集合

2. 与HashMap的区别：
HashMap在使用时都是先将键值对存储后, 才能够判断集合中是否存在某元素
而布隆过滤器在使用时只需要存储"某个元素是否存在与集合中"这个boolean值, 而不必存入实体类
因此, 如果是仅仅需要判断元素是否存在与集合中这么一个操作, 毫无疑问采用布隆过滤器更加高效

3. 底层实现
由一个很长的二进制向量和一系列随机映射函数组成, 若需要判断一个元素是否存在于集合, 只需要通过映射函数计算之后观察二进制向量中对应位置是否都为1, 即可判断元素是否存在某集合

4. 布隆过滤器缺点：
删除困难, 模糊查询

5. 使用场景：
由于其模糊查询的特性, 布隆过滤器可以充当一个外部缓存使用。假设我们需要在数据表查询某些数据, 如果在进入数据表中检索之前先通过布隆过滤器过滤掉那些一定不可能存在于数据表中的数据, 那么就可以省去很多无用的检索操作, 只需要查询可能存在于数据表的数据即可。
常用于Redis缓存, Hadoop, 垃圾邮件以及评论的过滤等

#### LRU Cahce 最近最少使用缓存
1. 怎么理解缓存：
我们可以把缓存理解为人脑的记忆, 例如两人同时做一道数学题, A已经背下了解题过程所以解答的速度非常快, B却要慢慢计算才能对问题进行解答。由此可见, 代码模块中的缓存对于提升程序性能有非常大的帮助。

2. LRU核心思想：
淘汰最久未使用的, 更新最近使用过的

3. 应用场景：
最直观的场景就是智能手机的后台进程, 假设后台进程的最大容量是3个进程, 当开启了3个后台进程后再开启一个新的进程, 此时就会淘汰调那个最久未使用的进程, 然后添加最新使用过的进程

4. 底层实现：
HashMap + 双端链表
采用双端链表+哈希表的数据结构, 保证了put、get方法的时间复杂度都为O(1)
put：涉及了链表的增、删操作, 双端链表数据结构保证了在链表头、尾部的增、删操作的时间复杂度为O(1)
get：涉及了链表的查找操作, 那么通过哈希表存储链表节点的key值, 这样就可以保证在获取指定节点的时间复杂度为O(1)

### 第十八课 排序算法

#### 初级排序和高级排序的实现和特性
##### 初级排序
1. 选择排序：每次找最小值, 放在待排序序列的起始位置

2. 插入排序：将序列分为待排序序列和已排序序列, 每次从待排序序列中选择第一个元素插入到已排序序列中的正确位置

3. 冒泡排序：每次遍历比较相邻元素, 若前者大于后者, 前者与后者交换, 也就是每一次遍历最大的元素会浮到序列最后一个位置

##### 高级排序
1. 快速排序：在序列中选取一个ref, 将小于ref的元素都放在ref左侧, 大于ref的元素都放在ref右侧, 然后对左半区和右半区分治

2. 归并排序：将序列分为两个子序列, 然后对这两个子序列递归调用归并排序, 将两个排序好的子序列进行合并

3. 堆排序：将序列分为待排序序列和已排序序列, 每次对待排序序列构建大顶堆, 然后将序列首元素与待排序元素末尾进行交换

4. 基数排序：每次排序整型序列的个位, 十位, 百位等


