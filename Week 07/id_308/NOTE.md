#### 位运算

- 按位异或(相同为0不同为1)
- 位运算符
    * 按位或 | 
    * 按位与 &
    * 按位取反 ~
    * 按位异或（相同为0不同为1） ^
- 异或
    * x^0 = x
    * x^1s = ~x
    * x^(~x) = 1s
    * x^x = 0
    * c = a^b -> a^c=b,b^c=a
    * a^b^c = a^(b^c) = (a^b)^c
- 实战位运算要点
    * 判断奇偶
        - x%2 == 1 -> (x&1)==1
        - x%2 == 0 -> (x&1)==0
    * x>>1 -> x/2
        即 x=x/2; -> x=x>>1
    * x=x&(x-1) 清零最低位的1
    * x&-x=> 得到最低位的1
    * x&-x=> 0



    
#### 布隆过滤器和LRU缓存

- 一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。
- 优点是空间效率和查询时间都远远超过一般的算法
- 缺点是有一定的误识别率和删除困难

#### LRU Cache - 替换策略

- 两个要素：大小、替换策略
- Hash Table + Double LinkedList
- 
    * O(1) 查询
    * Q(1) 修改 更新


#### 排序算法

- 比较类排序
    * 通过比较来决定元素间相对次序,由于其时间复杂度不能突破O(nlogn),因此也称为非线性时间比较类排序
- 非比较类排序
    * 不通过比较来决定元素间的相对次序,他可以突破基于比较排序的时间下限,以线性时间运行,因此也称为线性时间非比较类排序
- 初级排序
    * 选择排序
      - 每次找最小值,然后放到待排序数组的起始位置
    * 插入排序
      - 从前到后逐步构建有序序列,对于未排序数组,在已排序序列中从后向前扫描,找到相应位置并插入
    * 冒泡排序
      - 嵌套循环,每次查看相邻的元素如果逆序,则交换
- 高级排序
    * 快速排序
        - 数组取标杆pivot,将小元素放pivot左边,大元素放右边,然后依次对右边和右边的子数组继续快排;已达到整个序列有序
    * 归并排序
        - 把长度为n的输入序列分为2个长度为n/2的序列
        - 对这2个子序列分别采用归并排序
        - 将2个排序好的子序列合并成一个最终的排序序列
    * 堆排序 - 堆插入O(logN),取最大/小值O(1)
        - 数组元素依次建立小顶堆
        - 依次取顶堆元素,并删除
