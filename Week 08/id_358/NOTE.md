# 第8周学习总结

## 第19课 高级动态规划

### 回顾解决DP问题的步骤

1. 分解成子问题
2. 分治 + 最优子结构
3. 递推公式

### DP解法的代码模板

```
function dp() {
    dp = [][] // 定义状态数组，可能为一维，二维。。。
    // 初始化
    dp[0] or dp[0][x]
    for i in 0...m:
        for j in 0...n:
        // dp状态转移方程。
            dp[i][j] = _function(dp[i'][j'])
    return dp[m][n] // 返回结果
}
```

### 高级DP问题复杂度来源

1. 状态拥有更多维度
2. 状态方程更加复杂

### 实战题

#### 1.爬楼梯问题改进

定义更多状态数组

#### 2.编辑距离

1. BFS（双端BFS）
2. DP
   
dp[i][j]: word1的0...i 字符串与word2的0...j字符串的编辑距离

当 word1[i] === word2[j], dp[i][j] = dp[i-1][j-1]

否则， dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1

## 第20课 字符串问题

### 高级字符串算法

### 1. 编辑距离

#### 2. 最长公共子序列
    
if t[i] = s[j], dp[i][j] = dp[i-1][j-1] + 1

else dp[i][j] = max(dp[i-1][j], dp[i][j-1])

 return dp[m][n]

#### 3. 最长公共子串（连续且顺序相同）

if text1[j-1] = text2[i-1] dp[i][j] = dp[i-1][j-1] +1

else dp[i][j] = 0

#### 4. 最长回文子串

1. 暴力法

2. 枚举回文子串的中心

每次循环选择一个中心，左右扩展，判断左右是否相等。由于存在奇数偶数子串，需要分布从 i（中间元素）， i+1（元素中间空隙）扩展

3. 动态规划

dp[i][j] = true( s(i,j))是回文串， false(s(i,j))不是回文串

i是起点，j是终点

dp[i][j] = dp[i+1][j+1] && s[i] = s[j] (dp[i+1][j+1]) = true

#### 5 实现正则

dp


#### 6 不同的子序列

## 字符串匹配算法

1. 暴力法

2. 暴力法上改进

   1）预先判断： hash(txt.substring(i,m)) = hash(pat)，hash值一致则继续比较。也叫Rabin-karp 算法
   2) KMP 算法

### Rabin-Karp 算法思想

1. 设子串长度为M(pat),目标字符串长度为N（txt）
2. 计算子串的hash值 hash(pat)
3. 计算目标字符串中每个长度为M的子串的hash值，需要计算N-M+1次
4. 比较hash值，不同则不匹配，相同则还需要继续用朴素算法再次比较每个字符。

### KMP

1. 计算 前缀表
2. 循环字符串，根据前缀表，不断比较，横向移动