Week_08_学习总结

1、学习过程

	1）高级动态规划 2）字符串算法

2、本周学习内容（待细化）

	1）高级动态规划	

	2）字符串算法

3、高级动态规划

一、暴力枚举

1、实现代码

    `def` `fib(n):``    ``f ``=` `[``1``,``1``]``    ``for` `i ``in` `range``(``2``,n``+``1``):``        ``f.append(f[``-``1``]``+``f[``-``2``])``    ``print``(f)``    ``return` `f(n)` `fib(``5``)`

2、输出

    `"C:\Program Files\Python35\python.exe"` `E:``/``工作目录``/``python``/``test``/``DP.py``[``1``, ``1``, ``2``, ``3``, ``5``, ``8``]` `Process finished with exit code ``1`

二、动态规划定义

1、什么是动态规划？

动态规划的英文名，是一种分阶段求解决策略的数学思想，它不止用于编程领域，也用于管理学，经济学、生物学



2、初始为1

实现代码

    `def` `LTS(x):``    ``F ``=` `[``0` `for` `_ ``in` `range``(``len``(x))]``    ``F[``0``] ``=` `1``    ``for` `k ``in` `range``(``1``,``len``(F)):``        ``max_loc ``=` `None``        ``max_num ``=` `0``        ``for` `i ``in` `range``(``1``,k):``            ``if` `x[i] < x[k]:``                ``if` `F[i] > max_num:``                    ``max_loc ``=` `i``                    ``max_num ``=` `F[i]``        ``F[k] ``=` `max_num ``+` `1``    ``return` `F` `print``(LTS([``1``,``7``,``2``,``8``,``3``,``5``,``2``]))`

输出

    `"C:\Program Files\Python35\python.exe"` `E:``/``工作目录``/``python``/``test``/``DP.py``[``1``, ``1``, ``1``, ``2``, ``2``, ``3``, ``1``]` `Process finished with exit code ``0`

2、初始为0

1、实现代码

    `def` `LIS(x):``    ``F ``=` `[``0` `for` `_ ``in` `range``(``len``(x))]``    ``#初始化``    ``F[``0``] ``=` `1``    ``for` `k ``in` `range``(``1``,``len``(F)):``        ``max_loc ``=` `None``        ``max_num ``=` `0``        ``#内层循环表示[0:R] 里所有小于x[k]的对应位置的F[i]最大值``        ``for` `i ``in` `range``(``0``,k):``            ``if` `x[i] < x[k]:``                ``if` `F[i] > max_num:``                    ``max_loc ``=` `i``                    ``max_num ``=` `F[i]``        ``F[k] ``=` `max_num ``+` `1``    ``return` `F` `print``(LIS([``1``,``7``,``2``,``8``,``3``,``5``,``2``]))`

2、输出

    `"C:\Program Files\Python35\python.exe"` `E:``/``工作目录``/``python``/``test``/``DP.py``[``1``, ``2``, ``2``, ``3``, ``3``, ``4``, ``2``]` `Process finished with exit code ``0`

三、动态规划最长上升子序列



1、实现代码

    `def` `fib(n):``    ``f ``=` `[``1``,``1``]``    ``for` `i ``in` `range``(``2``,n``+``1``):``        ``f.append(f[``-``1``]``+``f[``-``2``])``    ``print``(f)``    ``return` `f(n)` `# fib(5)` `def` `LIS(x):``    ``F ``=` `[``0` `for` `_ ``in` `range``(``len``(x))]``    ``p ``=` `[``-``1` `for` `_ ``in` `range``(``len``(x))]``    ``#初始化``    ``F[``0``] ``=` `1``    ``p[``0``] ``=` `-``1``    ``for` `k ``in` `range``(``1``,``len``(F)):``        ``max_loc ``=` `-``1``        ``max_num ``=` `0``        ``#内层循环表示[0:R] 里所有小于x[k]的对应位置的F[i]最大值``        ``for` `i ``in` `range``(``0``,k):``            ``if` `x[i] < x[k]:``                ``if` `F[i] > max_num:``                    ``max_loc ``=` `i``                    ``max_num ``=` `F[i]``        ``F[k] ``=` `max_num ``+` `1``        ``p[k] ``=` `max_loc` `    ``max_i ``=` `0``    ``for` `i ``in` `range``(``1``,``len``(F)):``        ``if` `F[i] > F[max_i]:``            ``max_i ``=` `i``    ``lis ``=` `[]``    ``i ``=` `max_i``    ``while` `i >``=` `0``:``        ``lis.append(x[i])``        ``i ``=` `p[i]``    ``lis.reverse()``    ``return` `lis` `print``(LIS([``1``,``7``,``2``,``8``,``3``,``5``,``2``]))`

2、输出结果

    `"C:\Program Files\Python35\python.exe"` `E:``/``工作目录``/``python``/``test``/``DP.py``[``1``, ``2``, ``3``, ``5``]` `Process finished with exit code ``0`

最长公共子序列2



 最长公共子序列1



 

动态规划最优子结构



 

参考：

https://www.cnblogs.com/luoahong/p/9723117.html

4、字符串算法

字符串相关的一些算法，种类挺多的，特来整理一波。

字符串哈希(Hash)
简介
原理
哈希查找
字符串哈希
哈希的弊端 & 如何卡哈希
KMP算法
简介

1. 引言
2. 暴力匹配算法
3. KMP算法
3.1 定义
3.2 步骤
3.3 解释
3.3.1 寻找最长前缀后缀
3.3.2 基于《最大长度表》匹配
3.3.3 根据《最大长度表》求next 数组
3.3.4 通过代码递推计算next 数组
3.3.5 基于《next 数组》匹配
3.3.6 基于《最大长度表》与基于《next 数组》等价
3.3.7 Next 数组与有限状态自动机
3.3.8 Next 数组的优化
3.4 KMP的时间复杂度分析
4. 扩展1：BM算法
5. 扩展2：Sunday算法
6. 参考文献
7.后记
8.重编者（也就是我）记
字符串哈希(Hash)
简介
哈希( HashHash )是一种神奇的查找算法，广泛运用于计算机领域，它的强大在于设计得好的哈希算法可以使对一个对象的查找时间复杂度降为 O(1)O(1) ，这是朴素查找的 O(n)O(n) 和二分查找的 O(logn)O(log⁡n) 所远不能及的。

第一次了解到哈希这一种技术是在吴军 dalaodalao 的《数学之美》一书上（感谢 MasterYinMasterYin 的借阅！）讲解网络爬虫的数学原理的一章。有兴趣的话可以去读一读。

原理
哈希查找
为什么哈希查找的时间复杂度可以这么低呢？考虑下面一个问题：

设计一个程序，以完成以下输入输出： 
第一行，输入两个数字 n,mn,m 。 
第二行，输入 nn 个数字。 
第三行，输入 mm 个数字。对于每一个数字，询问其是否存在于第二行输入 nn 个数中，若是则输出”YES”，若不是则输出”NO”。 
数据说明：输入的数字的范围在 1,105 。

对于朴素算法，我们把第二行输入的数字储存在一个数组中。对于每一次询问，我们从左到右遍历整个数组来查询，每次询问的时间复杂度为 O(n)O(n) 。

对于二分查找算法，我们把第二行输入的数字进行排序。对于每一次询问，我们用二分查找的方法找到这个数字处在的位置，排序的时间复杂度为 O(logn)O(log⁡n) ，每次询问的时间复杂度也为 O(logn)O(log⁡n) 。

可是这一题真的有这么复杂吗？我们可以使用一个大小为 105105 的辅助数组 visvis 来表示一个数字是否出现过。对于第二行中输入的每一个数字 aa ，我们在 visvis 数组中进行记录： vis(a)=truevis(a)=true 。这样，对于每一次询问，我们只用 O(1)O(1) 的时间访问 visvis 数组，就可以得到询问的结果了。而哈希，就是运用了这样的思想：我们多开一个数组，用这些多申请的空间去解决时间上的复杂。这也正是应了那句名言：

以空间换时间。 —-蒋介石

字符串哈希
那么如果我们把题改一下呢？

设计一个程序，以完成以下输入输出： 
第一行，输入两个数字 n,mn,m 。 
第二行，输入 nn 个字符串。 
第三行，输入 mm 个字符串。对于每一个字符串，询问其是否存在于第二行输入 nn 个字符串中，若是则输出”YES”，若不是则输出”NO”。 
数据说明：输入的字符串的长度范围在 1,105 。

如果输入的是字符串的话，我们不就不能用 visvis 数组来储存了吗？这可怎么办？当然，如果你很熟悉 STLSTL 这一神奇的模板库，那么你一定会毫不犹豫地打出一行这样的代码：

map<string,bool>vis;
1
是的， mapmap 可以完美的解决这个问题。不过，我们可以试试用自己的力量来完成对字符串的处理：将字符串转换为数字。

怎样转换呢？我们知道，每一个字符都有它对应的 ASCIIASCII 码，也就是说，一个字符可以表示为一个数字。那么，如果把字符串看作是字符的连续，不就可以把每个字符的 ASCIIASCII 值连续起来表示字符串吗？我们可以运用这一点特性，将输入的字符串转换为一个 PP 进制数。在这里， PP 是一个大数。处理完后得到的 PP 进制数，就叫做这个字符串的哈希值。按照我的习惯，我会取 P=131P=131 。当然，如果你乐意，取点什么 P=233P=233 或 P=666P=666 也是可以的，不过很显然，计算难度也会随着 PP 的增大而逐步增大。

接下来给出一个函数 HashHash ，来获取一个字符串的哈希值：

const int P=131;

int Hash(string tmp)
{
    int hash=0;
    for(int i=0;i<tmp.length();i++)
        hash=hash*P+tmp[i];
    return hash;
}
1
2
3
4
5
6
7
8
9
可是我们又面临了一个问题，这是因为题目中写到：

数据说明：输入的字符串的长度范围在 1,105 。

字符串的最大长度是 105105 ！那 intint 不就爆炸了吗？

所以我们还要定义一个大数 MM ，在 HashHash 函数的运算过程中令运算结果对它取模，作为最后的字符串哈希值。依照我的习惯，我会取 M=99991M=99991 。当然，如果你乐意，取其它的值也是可以的。那么这个函数的运算就变成了：

const int P=131;
const int M=99991;

int Hash(string tmp)
{
    int hash=0;
    for(int i=0;i<tmp.length();i++)
        hash=(hash*P+tmp[i])%M;
    return hash;
}
1
2
3
4
5
6
7
8
9
10
这样我们就得到了一个字符串的哈希值，不过问题又出现了：怎样保证两个字符串的哈希各不相同？

这确实是哈希的一个大问题，具体来说有三种解决方法：

通过增加哈希池大小来降低两个字符串的哈希值冲突的概率。哈希池就是储存字符哈希值的地方，对应上述问题中的 visvis 数组。我们可以通过多模哈希或者增大 MM 的方式来达到这一结果，不过这样就会使得哈希计算过于复杂而且难以储存。
对于每个字符串的哈希值记录原有字符串，在冲突的情况下对原有字符串进行逐次比较。
第二种方法是我的常用方法，不过怎么实现呢？这里我们可以不使用 visvis 数组，而是转而使用神奇的 vectorvector 来达到这一点。不过这样的话，每次查找要调用一个函数 AddAdd ，每次询问要调用一个函数 QueryQuery ，具体来说这样写：

vector<string>v[M];

bool Query(string tmp)
{
    int pos=Hash(tmp);
    for(int i=0;i<v[pos].size();i++)
        if(vpos==tmp) return true;
    return false;
}
void Add(string tmp)
{
    if(Query(tmp)) return ;
    int pos=Hash(tmp);
    G[pos].push_back(tmp);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
这样就达到了我们的目的。这里给出一道字符串哈希的模板题：

Luogu P3370 【模板】字符串哈希

哈希的弊端 & 如何卡哈希
可是还有的人为了图代码书写方便而拒绝使用强大的 vectorvector 来进行储存，这样就会被毒瘤出题人卡，因为会有人思考出卡掉各种字符串哈希的方法，具体可见几道神题：

BZOJ 3097 Hash Killer I 
BZOJ 3098 Hash Killer II 
BZOJ 3099 Hash Killer III 
BZOJ 4917 [Lydsy1706月赛]Hash Killer IV (付费警告!)

在这些题目里，你被要扮演一个毒瘤出题人。因为你的后缀自动机神题被人用字符串哈希水掉了，所以你很不开心，决定用一组自造数据来卡掉他的代码。在这些题目中，给出水题的人的C++代码，要求你输出一组 hackhack 数据。

题目挺有意思，但是我们如何来操作呢？即，我们如何构造出两个相同的字符串，使它们的哈希值相同呢？

先拿第一题做例子。下面是题目大意：

Hash killer 1： 
本来的神题：给你一个长度为 NN 的字符串SS ，求有多少个不同的长度为 LL 的子串？ 
水过的人：给出一份 cpp ，其采用进制哈希配合 unsigned long long 的自然溢出来求出每一个长度为 LL 的子串的哈希值，然后使用排序去重得到不同的子串个数。 
你的输出：你现在需要给出一组可以卡掉这个算法的数据。 
数据大小：1≤N≤1051≤N≤105 。

自然溢出是什么意思呢？就是不去取 MM 的模，而是任由运算结果爆出数据范围，让储存范围自动地帮你取模。这也就相当于令 M=264M=264 。他的代码如下：

typedef unsigned long long u64;
const int MaxN = 100000;
inline int hash_handle(const char *s, const int &n, const int &l, const int &base)
{
    u64 hash_pow_l = 1;
    for(int i=1;i<=l;i++)
        hash_pow_l = base;
    int li_n = 0;
    static u64 li[MaxN];
    u64 val = 0;
    for(int i=0;i<l;i++)
        val=valbase+s[i]-'a';
    li[li_n++]=val;
    for(int i=l;i<n;i++)
    {
        val=valbase+s[i]-'a';
        val-=(s[i-l]-'a')hash_pow_l;
        li[li_n++]=val;
    }
    sort(li,li+li_n);
    li_n=unique(li,li+li_n)-li;
    return li_n;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
需要注意的事，这一代码中的基数 basebase 值（也就是我代码中的 PP 值）是随机的。那么我们就需要分类讨论：

如果基数 basebase 是偶数，那么 basebase 就可以写作一个整数与 22 相乘，而我们知道 M=264M=264 。那么字符串长度超过 6464 即可卡掉。例如这两个字符串的哈希值相同： 
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
（别数了，两个字符串长度都是 6565 ）
如果基数 basebase 是奇数:： 
我们可以构造两个字符串 str1 和 str2 ，我们队最终目的就是使它们满足 hash(str1)mod264=hash(str2)mod264hash(str1)mod264=hash(str2)mod264 。
即 (hash(str1)–hash(str2))mod264=0(hash(str1)–hash(str2))mod264=0 ，就能把代码卡掉。
令 0101 字符串 S[i]=S[i−1]+not(S[i−1]),S[0]=′0′S[i]=S[i−1]+not(S[i−1]),S[0]=′0′ 。其中，中括号中的 ii 仅表示字符串长度为 2i2i ， not(S[i−1])not(S[i−1]) 表示对 0101 字符串 S[i−1]S[i−1] 的每一位取反。
接下来定义 h(x)=hash(S[x]),hn(x)=hash(not(S[x]))h(x)=hash(S[x]),hn(x)=hash(not(S[x])) 。
根据之前的定义以及进制哈希的特性，显然有： 
h(i)–hn(i)=h(i−1)×base2i−1+hn(i−1)−hn(i−1)×base2i−1–h(i−1)=(h(i−1)–hn(i−1))×(base2i−1−1)
h(i)–hn(i)=h(i−1)×base2i−1+hn(i−1)−hn(i−1)×base2i−1–h(i−1)=(h(i−1)–hn(i−1))×(base2i−1−1)
对于 base2i−1−1base2i−1−1 ，我们可以用神奇的欧拉定理得到： 
==(base2i−1−1)mod2i(base0−1)mod2i0
(base2i−1−1)mod2i=(base0−1)mod2i=0
所以我们就可以把上面的式子进行转换： 
(h(i−1)–hn(i−1))×(base2i−1−1)=(h(i−1)–hn(i−1))×2ik
(h(i−1)–hn(i−1))×(base2i−1−1)=(h(i−1)–hn(i−1))×2ik
其中的k是个没什么用的常数。然后我们用相同的方法拆啊拆啊拆，便可以得到： 
==h(i)–hn(i)21+2+3+⋯+ik2(1+i)i2k
h(i)–hn(i)=21+2+3+⋯+ik=2(1+i)i2k
我们接下来只需要让 2(1+i)i2≥2642(1+i)i2≥264 就好啦。经过简单的计算，我们要让 i≥11i≥11 。
恭喜你，经过了层层计算，终于卡掉了他的代码！（体会到毒瘤出题人的艰辛）

接下来我们再来看看相对与计算无关的第二题吧。神题还是一模一样，只不过水题的人不打算使用自然溢出了，而是打算用模大质数的方法（这是剽窃我的代码啊喂）。而且喜欢大数字的他打算加大哈希池，令 M=109+7M=109+7 。他的代码是这样的：

typedef unsigned long long u64;
const int MaxN = 100000;

inline int hash_handle(const char s, const int &n, const int &l, const int &base)
{
    const int Mod=1000000007;
    u64 hash_pow_l=1;
    for(int i=1;i<=l;i++)
        hash_pow_l=(hash_pow_lbase)%Mod;
    int li_n=0;
    static int li[MaxN];
    u64 val=0;
    for(int i=0;i<l;i++)
        val=(valbase+s[i]-'a')%Mod;
    li[li_n++]=val;
    for(int i=l;i<n;i++)
    {
        val=(valbase+s[i]-'a')%Mod;
        val=(val+Mod-((s[i-l]-'a')*hash_pow_l)%Mod)%Mod;
        li[li_n++]=val;
    }
    sort(li,li+li_n);
    li_n =unique(li,li+li_n)-li;
    return li_n;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
这道题的做法也不难，但是要考验你的欧气了，先来了解一个神奇的悖论：

生日悖论_百度百科

那么同样的，如果你用大量的数据去卡他，他不就废了吗？不过如果你足够非，你还是可以WA到飞起的。

KMP算法
简介
三名算法大佬克努特（ D.E.KnuthD.E.Knuth ）、莫里斯（ J.H.MorrisJ.H.Morris ）以及普拉特（ V.R.PrattV.R.Pratt ）改进了字符串匹配算法，所以我们合称这个算法为 KMPKMP 算法。网上对于这种算法有很多的讲解，而讲的最好的非这一篇莫属了。感谢这位大佬详尽的讲解。摘录于此，方便大家学习：

原文地址：v_JULY_v 的博客

1. 引言
本 KMPKMP 原文最初写于 22 年多前的 20112011 年 1212 月，因当时初次接触 KMPKMP ，思路混乱导致写也写得混乱。所以一直想找机会重新写下 KMPKMP ，但苦于一直以来对 KMPKMP 的理解始终不够，故才迟迟没有修改本文。

然近期因开了个算法班，班上专门讲解数据结构、面试、算法，才再次仔细回顾了这个 KMPKMP ，在综合了一些网友的理解、以及算法班的两位讲师朋友曹博、邹博的理解之后，写了 99 张 PPTPPT ，发在微博上。随后，一不做二不休，索性将 PPTPPT 上的内容整理到了本文之中（后来文章越写越完整，所含内容早已不再是九张 PPTPPT 那样简单了）。

KMPKMP 本身不复杂，但网上绝大部分的文章（包括本文的 20112011 年版本）把它讲混乱了。下面，咱们从暴力匹配算法讲起，随后阐述 KMPKMP 的流程、步骤、 nextnext 数组的简单求解、递推原理、代码求解，接着基于 nextnext 数组匹配，谈到有限状态自动机， nextnext 数组的优化， KMPKMP 的时间复杂度分析，最后简要介绍两个 KMPKMP 的扩展算法。

全文力图给你一个最为完整最为清晰的 KMPKMP ，希望更多的人不再被 KMPKMP 折磨或纠缠，不再被一些混乱的文章所混乱。有何疑问，欢迎随时留言评论， thanksthanks 。

2. 暴力匹配算法
假设现在我们面临这样一个问题：有一个文本串 SS ，和一个模式串 PP ，现在要查找 PP 在 SS 中的位置，怎么查找呢？

如果用暴力匹配的思路，并假设现在文本串 SS 匹配到 ii 位置，模式串 PP 匹配到 jj 位置，则有：

如果当前字符匹配成功（即 S[i] == P[j] ），则 i++,j++ ，继续匹配下一个字符；

如果失配（即 S[i] != P[j] ），令 i = i - (j - 1),j = 0 。相当于每次匹配失败时， ii 回溯， jj 被置为 00 。

理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：

int ViolentMatch(char* s, char* p)
{
    int sLen = strlen(s);
    int pLen = strlen(p);

    int i = 0;
    int j = 0;
    while (i < sLen && j < pLen)
    {
        if (s[i] == p[j])
        {
            //如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    
            i++;
            j++;
        }
        else
        {
            //如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    
            i = i - j + 1;
            j = 0;
        }
    }
    //匹配成功，返回模式串p在文本串s中的位置，否则返回-1
    if (j == pLen)
        return i - j;
    else
        return -1;
    

}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
举个例子，如果给定文本串 SS "BBC ABCDAB ABCDABCDABDE" ，和模式串 PP "ABCDABD" ，现在要拿模式串 PP 去跟文本串 SS 匹配，整个过程如下所示：

S[0] 为 B ， P[0] 为 A ，不匹配，执行第②条指令：“如果失配（即 S[i] != P[j] ），令 i = i - (j - 1)，j = 0 ， S[1] 跟 P[0] 匹配，相当于模式串要往右移动一位（ i=1,j=0 ）。

S[1] 跟 P[0] 还是不匹配，继续执行第②条指令：如果失配（即 S[i] != P[j] ），令 i = i - (j - 1),j = 0 ， S[2] 跟 P[0] 匹配（ i=2,j=0 ），从而模式串不断的向右移动一位（不断的执行令 i = i - (j - 1),j = 0 ， ii 从 22 变到 44 ， jj 一直为 00 ）。

直到 S[4] 跟 P[0] 匹配成功（i=4,j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：如果当前字符匹配成功（即 S[i] == P[j] ），则 i++,j++ ，可得 S[i] 为 S[5] ， P[j] 为 P[1] ，即接下来 S[5] 跟 P[1]匹配（ i=5,j=1 ）。

S[5] 跟 P[1] 匹配成功，继续执行第①条指令：如果当前字符匹配成功（即 S[i] == P[j] ），则 i++,j++ ，得到 S[6] 跟 P[2] 匹配（ i=6,j=2 ），如此进行下去。

直到 S[10] 为空格字符， P[6] 为字符 D （i=10,j=6 ），因为不匹配，重新执行第②条指令：“如果失配（即 S[i] != P[j] ），令 i = i - (j - 1),j = 0 ，相当于 S[5] 跟 P[0] 匹配（ i=5,j=0 ）。

至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了 S[9] 、 P[5] ，但因为 S[10] 跟 P[6] 不匹配，所以文本串回溯到 S[5] ，模式串回溯到 P[0] ，从而让 S[5] 跟 P[0] 匹配。

而 S[5] 肯定跟 P[0] 失配。为什么呢？因为在之前第 44 步匹配中，我们已经得知 S[5] = P[1] = B ，而 P[0] = A ，即 P[1] != P[0] ，故 S[5] 必定不等于 P[0] ，所以回溯过去必然会导致失配。那有没有一种算法，让 i 不往回退，只需要移动 j 即可呢？

答案是肯定的。这种算法就是本文的主旨 KMPKMP 算法，它利用之前已经部分匹配这个有效信息，保持 ii 不回溯，通过修改 jj 的位置，让模式串尽量地移动到有效的位置。

3. KMP算法
3.1 定义
Knuth−Morris−PrattKnuth−Morris−Pratt 字符串查找算法，简称为 “KMPKMP算法”，常用于在一个文本串SS内查找一个模式串PP的出现位置，这个算法由DonaldKnuthDonaldKnuth、VaughanPrattVaughanPratt、JamesH.MorrisJamesH.Morris三人于19771977年联合发表，故取这33人的姓氏命名此算法。

下面先直接给出KMPKMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明）：

假设现在文本串SS匹配到ii位置，模式串PP匹配到jj位置。

如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++,j++，继续匹配下一个字符；

如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令i不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next[j]` 位。

换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的nextnext值（nextnext数组的求解会在下文的3.3.33.3.3节中详细阐述），即移动的实际位数为：j−next[j]j−next[j]，且此值大于等于11。
很快，你也会意识到nextnext数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j]=knext[j]=k，代表jj之前的字符串中有最大长度为kk的相同前缀后缀。

此也意味着在某个字符失配时，该字符对应的nextnext值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next[j]next[j]的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next[j]=knext[j]=k且k>0k>0，代表下次匹配跳到jj之前的某个字符，而不是跳到开头，且具体跳过了kk个字符。

转换成代码表示，则是：

int KmpSearch(char* s, char* p)
{
    int i = 0;
    int j = 0;
    int sLen = strlen(s);
    int pLen = strlen(p);
    while (i < sLen && j < pLen)
    {
        //如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
        if (j == -1 || s[i] == p[j])
        {
            i++;
            j++;
        }
        else
        {
            //如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
            //next[j]即为j所对应的next值      
            j = next[j];
        }
    }
    if (j == pLen)
        return i - j;
    else
        return -1;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMPKMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令i不变，j = next[j]”，即j从6变到2（后面我们将求得P[6]，即字符D对应的next值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] = 6-2 = 4）。



向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]、S[9]对应着，从而不用让i回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next数组，最后基于next数组进行匹配（不关心next数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.43.3.4节）。



3.2 步骤
①寻找前缀后缀最长公共元素长度

对于P=p[0,j]P=p[0,j]，寻找模式串PP中长度最大且相等的前缀和后缀。如果存在p[0,k]=p[j−k,j]p[0,k]=p[j−k,j]，那么在包含pjpj的模式串中有最大长度为k+1k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：

比如对于字符串"aba"来说，它有长度为11的相同前缀后缀a；而对于字符串abab来说，它有长度为22的相同前缀后缀ab（相同前缀后缀的长度为k+1k+1，k+1=2k+1=2）。

②求nextnext数组

nextnext数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为−1−1，如下表格所示：

比如对于aba来说，第33个字符a之前的字符串ab中有长度为00的相同前缀后缀，所以第33个字符a对应的nextnext值为00；而对于abab来说，第44个字符b之前的字符串aba中有长度为11的相同前缀后缀a，所以第44个字符b对应的nextnext值为11（相同前缀后缀的长度为kk，k=1k=1）。

③根据nextnext数组进行匹配

匹配失配，j = next[j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀p[j−k,j−1]p[j−k,j−1]跟文本串s[i−k,i−1]s[i−k,i−1]匹配成功，但pjpj跟sisi匹配失败时，因为next[j] = k，相当于在不包含pjpj的模式串中有最大长度为kk的相同前缀后缀，即p[0,k−1]=p[j−k,j−1]p[0,k−1]=p[j−k,j−1]，故令j = next[j]，从而让模式串右移j - next[j]位，使得模式串的前缀p[0,k−1]p[0,k−1]对应着文本串s[i−k,i−1]s[i−k,i−1]，而后让pkpk跟sisi继续匹配。如下图所示：

综上，KMPKMP的nextnext数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在jj处的字符跟文本串在ii处的字符匹配失配时，下一步用next[j]next[j]处的字符继续跟文本串ii处的字符匹配，相当于模式串向右移动j - next[j]位。

接下来，分别具体解释上述33个步骤。

3.3 解释
3.3.1 寻找最长前缀后缀
如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：



也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）：



3.3.2 基于《最大长度表》匹配
因为模式串中首尾可能会有重复的字符，故可得出下述结论：

失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。

下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：



因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第55个字符A匹配成功：

继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为66个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为22，所以根据之前的结论，可知需要向右移动6−2=46−2=4位。

模式串向右移动44位后，发现C处再度失配，因为此时已经匹配了22个字符（AB），且上一位字符B对应的最大长度值为00，所以向右移动：2−0=22−0=2位。

A与空格失配，向右移动11位。

继续比较，发现D与C失配，故向右移动的位数为：已匹配的字符数66减去上一位字符B对应的最大长度22，即向右移动6−2=46−2=4位。

经历第55步后，发现匹配成功，过程结束。

通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是nextnext数组要表达的含义。

3.3.3 根据《最大长度表》求next 数组
由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：



而且，根据这个表可以得出下述结论

失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值
上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了nextnext数组。

给定字符串“ABCDABD”，可求得它的nextnext数组如下：



把nextnext数组跟之前求得的最大长度表对比后，不难发现，nextnext数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为−1−1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为−1−1（当然，你也可以直接计算某个字符对应的nextnext值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。

换言之，对于给定的模式串：ABCDABD，它的最大长度表及nextnext数组分别如下：



根据最大长度表求出了nextnext数组后，从而有

失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的nextnext值
而后，你会发现，无论是基于《最大长度表》的匹配，还是基于nextnext数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：

根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值。

而根据《nextnext数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的nextnext值。

其中，从00开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的nextnext值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。
所以，你可以把《最大长度表》看做是nextnext数组的雏形，甚至就把它当做nextnext数组也是可以的，区别不过是怎么用的问题。

3.3.4 通过代码递推计算next 数组
接下来，咱们来写代码求下nextnext数组。

基于之前的理解，可知计算nextnext数组的方法可以采用递推：

1.如果对于值kk，已有p[0,k−1]=p[j−k,j−1]p[0,k−1]=p[j−k,j−1]，相当于next[j]=knext[j]=k。

此意味着什么呢？究其本质，next[j] = k代表p[j]之前的模式串子串中，有长度为kk的相同前缀和后缀。有了这个nextnext数组，在KMPKMP匹配中，当模式串中j处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j]位。
举个例子，如下图，根据模式串“ABCDABD”的nextnext数组可知失配位置的字符D对应的nextnext值为22，代表字符D前有长度为22的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] = 6 - 2 =4位。 

向右移动44位后，模式串中的字符C继续跟文本串匹配。 

2.下面的问题是：已知next[0,j]next[0,j]，如何求出next[j+1]next[j+1]呢？
对于PP的前j+1j+1个序列字符：

若p[k] == p[j]，则next[j + 1] = next[j] + 1 = k + 1；

若p[k] != p[j]，如果此时p[next[k]] == p[j]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1k+1的前缀p[0,k]p[0,k]跟后缀p[j−k,j]p[j−k,j]相等，那么是否可能存在另一个值t+1<k+1t+1<k+1，使得长度更小的前缀p[0,t]p[0,t]等于长度更小的后缀p[j−t,j]p[j−t,j]呢？如果存在，那么这个t+1t+1便是next[j+1]next[j+1]的值，此相当于利用已经求得的nextnext数组（next[0,…,k,…,j]next[0,…,k,…,j]）进行PP串前缀跟PP串后缀的匹配。

一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解nextnext数组的原理，故接下来，我再来着重说明下。

如下图所示，假定给定模式串ABCDABCE，且已知next[j]=knext[j]=k（相当于p[0,k−1]=p[j−k,j−1]=ABp[0,k−1]=p[j−k,j−1]=AB，可以看出kk为22），现要求next[j+1]next[j+1]等于多少？因为pk=pj=′C′pk=pj=′C′，所以next[j+1]=next[j]+1=k+1next[j+1]=next[j]+1=k+1（可以看出next[j+1]=3next[j+1]=3）。代表字符E前的模式串中，有长度k+1k+1的相同前缀后缀。



但如果p[k] != p[j]呢？说明p[0,k]≠p[j−k,j]p[0,k]≠p[j−k,j]。换言之，当p[k] != p[j]后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC跟ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单地令：next[j + 1] = next[j] + 1。所以，咱们只能去寻找长度更短一点的相同前缀后缀。



结合上图来讲，若能在前缀p[0,k]p[0,k]中不断的递归前缀索引k=next[k]k=next[k]，找到一个字符pk′pk′也为D，代表pk′=pjpk′=pj，且满足p[0,k′]=p[j−k′,j]p[0,k′]=p[j−k′,j]，则最大相同的前缀后缀长度为k′+1k′+1，从而next[j+1]=k′+1=next[k′]+1next[j+1]=k′+1=next[k′]+1。否则前缀中没有D，则代表没有相同的前缀后缀，next[j+1]=0next[j+1]=0。

那为何递归前缀索引k=next[k]k=next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到nextnext数组的含义。我们拿前缀p[0,k]p[0,k]去跟后缀p[j−k,j]p[j−k,j]匹配，如果pkpk跟pjpj失配，下一步就是用p[next[k]]p[next[k]]去跟pjpj继续匹配，如果p[next[k]]p[next[k]]跟pjpj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[next[next[k]]]p[next[next[k]]]去跟pjpj匹配。此过程相当于模式串的自我匹配，所以不断的递归k=next[k]k=next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：



所以，因最终在前缀ABC中没有找到D，故E的nextnext值为00：

模式串的后缀：ABDE 
模式串的前缀：ABC 
前缀右移两位：     ABC

读到此，有的读者可能又有疑问了，那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示：



给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pjpj处的字符D跟pkpk处的字符C不一样，换言之，前缀DABC的最后一个字符C跟后缀DABD的最后一个字符D不相同，所以不存在长度为44的相同前缀后缀。

怎么办呢？既然没有长度为44的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0p0处发现也有个字符D，p0=pjp0=pj，所以p[j]对应的长度值为11，相当于E对应的nextnext值为11（即字符E之前的字符串“DABCDABD”中有长度为11的相同前缀和后缀）。

综上，可以通过递推求得nextnext数组，代码如下所示：

void GetNext(char* p,int next[])
{
    int pLen = strlen(p);
    next[0] = -1;
    int k = -1;
    int j = 0;
    while (j < pLen - 1)
    {
        //p[k]表示前缀，p[j]表示后缀
        if (k == -1 || p[j] == p[k]) 
        {
            ++k;
            ++j;
            next[j] = k;
        }
        else 
        {
            k = next[k];
        }
    }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
用代码重新计算下“ABCDABD”的nextnext数组，以验证之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为−1−1”得到的nextnext数组是否正确，计算结果如下表格所示：



从上述表格可以看出，无论是之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为−1−1”得到的nextnext数组，还是之后通过代码递推计算求得的nextnext数组，结果是完全一致的。

3.3.5 基于《next 数组》匹配
下面，我们来基于nextnext数组进行匹配。



还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：



在正式匹配之前，让我们来再次回顾下上文2.12.1节所述的KMPKMP算法的匹配流程：

“假设现在文本串SS匹配到ii位置，模式串PP匹配到jj位置

如果j == -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++,j++，继续匹配下一个字符；
如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令i不变，j = next[j]。此举意味着失配时，模式串PP相对于文本串SS向右移动了j - next[j]位。 
换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的nextnext值，即移动的实际位数为：j - next[j]，且此值大于等于11。”
1.最开始匹配时

P[0]P[0]跟S[0]S[0]匹配失败 
所以执行“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令i不变，j = next[j]”，所以j = -1，故转而执行“如果j = -1，或者当前字符匹配成功（即S[i]==P[j]S[i]==P[j]），都令i++,j++”，得到i = 1,j = 0，即P[0]P[0]继续跟S[1]S[1]匹配。
P[0]P[0]跟S[1]S[1]又失配，jj再次等于−1−1，ii、jj继续自增，从而P[0]P[0]跟S[2]S[2]匹配。
P[0]P[0]跟S[2]S[2]失配后，P[0]P[0]又跟S[3]S[3]匹配。
P[0]P[0]跟S[3]S[3]再失配，直到P[0]P[0]跟S[4]S[4]匹配成功，开始执行此条指令的后半段：“如果j == -1，或者当前字符匹配成功（即S[i]==P[j]S[i]==P[j]），都令i++,j++”。

2.P[1]P[1]跟S[5]S[5]匹配成功，P[2]P[2]跟S[6]S[6]也匹配成功, …，直到当匹配到P[6]P[6]处的字符D时失配（即S[10]!=P[6]S[10]!=P[6]），由于P[6]P[6]处的D对应的nextnext值为22，所以下一步用P[2]P[2]处的字符C继续跟S[10]S[10]匹配，相当于向右移动：j−next[j]=6−2=4j−next[j]=6−2=4位。

3.向右移动44位后，P[2]P[2]处的C再次失配，由于C对应的nextnext值为00，所以下一步用P[0]P[0]处的字符继续跟S[10]S[10]匹配，相当于向右移动：j−next[j]=2−0=2j−next[j]=2−0=2位。



4.移动两位之后，AA跟空格不匹配，模式串后移11位。



5.P[6]P[6]处的D再次失配，因为P[6]P[6]对应的nextnext值为22，故下一步用P[2]P[2]继续跟文本串匹配，相当于模式串向右移动j - next[j] = 6 - 2 = 4位。



6.匹配成功，过程结束。



匹配过程一模一样。也从侧面佐证了，nextnext数组确实是只要将各个最大前缀后缀的公共元素的长度值右移一位，且把初值赋为−1−1即可。

3.3.6 基于《最大长度表》与基于《next 数组》等价
我们已经知道，利用nextnext数组进行匹配失配时，模式串向右移动j - next[j]位，等价于已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。原因是：

jj从00开始计数，那么当数到失配字符时，jj的数值就是已匹配的字符数；
由于nextnext数组是由最大长度值表整体向右移动一位（且初值赋为−1−1）得到的，那么失配字符的上一位字符所对应的最大长度值，即为当前失配字符的nextnext值。
但为何本文不直接利用nextnext数组进行匹配呢？因为nextnext数组不好求，而一个字符串的前缀后缀的公共元素的最大长度值很容易求。例如若给定模式串“ababa”，要你快速口算出其nextnext数组，乍一看，每次求对应字符的nextnext值时，还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的相同前缀后缀，此过程不够直接。而如果让你求其前缀后缀公共元素的最大长度，则很容易直接得出结果：0 0 1 2 3，如下表格所示：



然后这55个数字 全部整体右移一位，且初值赋为−1−1，即得到其nextnext数组：-1 0 0 1 2。

3.3.7 Next 数组与有限状态自动机
nextnext负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]next[j]位和主串匹配，就像打了张“表”。此外，nextnext也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。



3.3.8 Next 数组的优化
行文至此，咱们全面了解了暴力匹配的思路、KMPKMP算法的原理、流程、流程之间的内在逻辑联系，以及nextnext数组的简单求解（《最大长度表》整体右移一位，然后初值赋为−1−1）和代码求解，最后基于《nextnext数组》的匹配，看似洋洋洒洒，清晰透彻，但以上忽略了一个小问题。

比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为−1−1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 = 2位。



右移22位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3]=bp[3]=b，与s[3]=cs[3]=c失配，而右移两位之后，让p[next[3]]=p[1]=bp[next[3]]=p[1]=b再跟s[3]s[3]匹配时，必然失配。问题出在哪呢？



问题出在不该出现p[j]=p[next[j]]p[j]=p[next[j]]。为什么呢？理由是：当p[j]≠s[i]p[j]≠s[i]时，下次匹配必然是p[next[j]]p[next[j]]跟s[i]s[i]匹配，如果p[j]=p[next[j]]p[j]=p[next[j]]，必然导致后一步匹配失败（因为p[j]p[j]已经跟s[i]s[i]失配，然后你还用跟p[j]p[j]等同的值p[next[j]]p[next[j]]去跟s[i]s[i]匹配，很显然，必然失配），所以不能允许p[j]=p[next[j]]p[j]=p[next[j]]。如果出现了p[j]=p[next[j]]p[j]=p[next[j]]咋办呢？如果出现了，则需要再次递归，即令next[j]=next[next[j]]next[j]=next[next[j]]。

所以，咱们得修改下求nextnext数组的代码。

//优化过后的next 数组求法
void GetNextval(char* p, int next[])
{
    int pLen = strlen(p);
    next[0] = -1;
    int k = -1;
    int j = 0;
    while (j < pLen - 1)
    {
        //p[k]表示前缀，p[j]表示后缀  
        if (k == -1 || p[j] == p[k])
        {
            ++j;
            ++k;
            //较之前next数组求法，改动在下面4行
            if (p[j] != p[k])
                next[j] = k;   //之前只有这一行
            else
                //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]
                next[j] = next[k];
        }
        else
        {
            k = next[k];
        }
    }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
利用优化过后的nextnext数组求法，可知模式串“abab”的新nextnext数组为：-1 0 -1 0。可能有些读者会问：原始nextnext数组是前缀后缀最长公共元素长度值右移一位， 然后初值赋为−1−1而得，那么优化后的nextnext数组如何快速心算出呢？实际上，只要求出了原始nextnext数组，便可以根据原始nextnext数组快速求出优化后的nextnext数组。还是以abab为例，如下表格所示：



只要出现了p[next[j]]=p[j]p[next[j]]=p[j]的情况，则把next[j]next[j]的值再次递归。例如在求模式串“abab”的第22个a的nextnext值时，如果是未优化的nextnext值的话，第22个a对应的nextnext值为00，相当于第22个a失配时，下一步匹配模式串会用p[0]p[0]处的a再次跟文本串匹配，必然失配。所以求第22个a的nextnext值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新nextnext值可知，第22个a失配时，执行“如果j == -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++,j++，继续匹配下一个字符”），同理，第22个b对应的nextnext值为00。

对于优化后的nextnext数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的nextnext值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的nextnext数组为：-1 0 0 -1 0 0，前缀后缀abc的nextnext值都为-1 0 0。

然后引用下之前3.13.1节的KMPKMP代码：

int KmpSearch(char* s, char* p)
{
    int i = 0;
    int j = 0;
    int sLen = strlen(s);
    int pLen = strlen(p);
    while (i < sLen && j < pLen)
    {
        //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
        if (j == -1 || s[i] == p[j])
        {
            i++;
            j++;
        }
        else
        {
            //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
            //next[j]即为j所对应的next值      
            j = next[j];
        }
    }
    if (j == pLen)
        return i - j;
    else
        return -1;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
接下来，咱们继续拿之前的例子说明，整个匹配过程如下：

S[3]S[3]与P[3]P[3]匹配失败。

S[3]S[3]保持不变，PP的下一个匹配位置是P[next[3]]P[next[3]]，而next[3]=0next[3]=0，所以P[next[3]]=P[0]P[next[3]]=P[0]与S[3]S[3]匹配。

由于上一步骤中P[0]P[0]与S[3]S[3]还是不匹配。此时i=3i=3，j=next[0]=−1j=next[0]=−1，由于满足条件j==−1j==−1，所以执行“++i,++j”，即主串指针下移一个位置，P[0]P[0]与S[4]S[4]开始匹配。最后j==pLen，跳出循环，输出结果i - j = 4（即模式串第一次在文本串中出现的位置），匹配成功，算法结束。

3.4 KMP的时间复杂度分析
相信大部分读者读完上文之后，已经发觉其实理解KMPKMP非常容易，无非是循序渐进把握好下面几点：

如果模式串中存在相同前缀和后缀，即p[j−k,j−1]=p[0,k−1]p[j−k,j−1]=p[0,k−1]，那么在pjpj跟sisi失配后，让模式串的前缀p[0,k−1]p[0,k−1]对应着文本串s[i−k,i−1]s[i−k,i−1]，而后让pkpk跟sisi继续匹配。

之前本应是pjpj跟sisi匹配，结果失配了，失配后，令pkpk跟sisi匹配，相当于jj变成了kk，模式串向右移动j−kj−k位。

因为k 的值是可变的，所以我们用next[j]next[j]表示jj处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是jj，pjpj跟sisi失配时，用p[next[j]]p[next[j]]继续跟sisi匹配，相当于jj变成了next[j]next[j]，所以，j=next[j]j=next[j]，等价于把模式串向右移动j−next[j]j−next[j]位。

而next[j]next[j]应该等于多少呢？next[j]next[j]的值由jj之前的模式串子串中有多大长度的相同前缀后缀所决定，如果jj之前的模式串子串中（不含jj）有最大长度为kk的相同前缀后缀，那么next[j]=knext[j]=k。

如之前的图所示：



接下来，咱们来分析下KMPKMP的时间复杂度。分析之前，先来回顾下KMPKMP匹配算法的流程：

KMPKMP的算法流程： 
假设现在文本串SS匹配到ii位置，模式串PP匹配到jj位置 
如果j == -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++,j++，继续匹配下一个字符；
如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令i不变，j = next[j]。此举意味着失配时，模式串PP相对于文本串SS向右移动了j - next [j]位。
我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++,j++；如果匹配失配，i不变（即i不回溯），模式串会跳过匹配过的next[j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。

所以，如果文本串的长度为nn，模式串的长度为mm，那么匹配过程的时间复杂度为O(n)O(n)，算上计算nextnext的O(m)O(m)时间，KMPKMP的整体时间复杂度为O(m+n)O(m+n)。

4. 扩展1：BM算法
KMPKMP 的匹配是从模式串的开头开始匹配的，而 19771977 年，德克萨斯大学的 RobertS.BoyerRobertS.Boyer 教授和 JStrotherMooreJStrotherMoore 教授发明了一种新的字符串匹配算法： Boyer−MooreBoyer−Moore 算法，简称BMBM 算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下 O(N)O(N) 的时间复杂度。在实践中，比 KMPKMP 算法的实际效能高。

BMBM 算法定义了两个规则：

坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为 −1−1 。

好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为 −1−1 。

下面举例说明BM算法。例如，给定文本串 “HERE IS A SIMPLE EXAMPLE”，和模式串 “EXAMPLE” ，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。

1.首先，”文本串”与”模式串”头部对齐，从尾部开始比较。 'S' 与 'E' 不匹配。这时， 'S' 就被称为”坏字符”（ badcharacterbadcharacter ），即不匹配的字符，它对应着模式串的第6位。且 'S' 不包含在模式串 "EXAMPLE" 之中（相当于最右出现位置是 −1−1 ），这意味着可以把模式串后移6 - (-1) = 7位，从而直接移到 'S' 的后一位。



2.依然从尾部开始比较，发现 'P' 与 'E' 不匹配，所以 'P' 是”坏字符”。但是， 'P' 包含在模式串 "EXAMPLE" 之中。因为 'P' 这个“坏字符”对应着模式串的第 66 位（从 00 开始编号），且在模式串中的最右出现位置为 44 ，所以，将模式串后移6 - 4 = 2位，两个 'P' 对齐。

 

3.依次比较，得到 “MPLE” 匹配，称为”好后缀”（ goodsuffixgoodsuffix ），即所有尾部匹配的字符串。注意， "MPLE" 、 "PLE" 、 "LE" 、 "E" 都是好后缀。



4.发现 'I' 与 'A' 不匹配： 'I' 是坏字符。如果是根据坏字符规则，此时模式串应该后移2 - (-1) = 3位。问题是，有没有更优的移法？

 

5.更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为 −1−1 。

所有的“好后缀”（ "MPLE" 、 "PLE" 、 "LE" 、 "E" ）之中，只有 'E' 在 “EXAMPLE” 的头部出现，所以后移6 - 0 = 6位。

可以看出，“坏字符规则”只能移 33 位，“好后缀规则”可以移 66 位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。



6.继续从尾部开始比较， 'P' 与'E' 不匹配，因此 'P' 是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。



由上可知， BMBM 算法不仅效率高，而且构思巧妙，容易理解。

5. 扩展2：Sunday算法
上文中，我们已经介绍了 KMPKMP 算法和 BMBM 算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上， KMPKMP 算法并不比最简单的 CC 库函数 strstr() 快多少，而 BMBM 算法虽然通常比 KMPKMP 算法快，但 BMBM 算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比 BMBM 算法更快的查找算法即 SundaySunday 算法。

SundaySunday 算法由 DanielM.SundayDanielM.Sunday 在 19901990 年提出，它的思想跟 BMBM 算法很相似：

只不过 SundaySunday 算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。

如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；

否则，其移动位数 = 模式串中最右端的该字符到末尾的距离 + 1。

下面举个例子说明下 SundaySunday 算法。假定现在要在文本串 "substring searching algorithm" 中查找模式串 "search" 。

1.刚开始时，把模式串与文本串左边对齐：

substr i ng searching algorithm 
search 
^

2.结果发现在第 22 个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i ，因为模式串 "search" 中并不存在 i ，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符 n ）开始下一步的匹配，如下图：

substring searching algorithm 
　　　 search 
　　　　^

3.结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是 'r' ，它出现在模式串中的倒数第 33 位，于是把模式串向右移动 33 位（ 'r' 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个 'r' 对齐，如下：

substring searching algorithm 
　　　　 search 
　　　　　　　^

4.匹配成功。

回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于 SundaySunday 算法每一步的移动量都比较大，效率很高。完。
————————————————
版权声明：本文为CSDN博主「UranusITS」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/UranusITS/article/details/81063801

https://blog.csdn.net/UranusITS/article/details/81063801


  

