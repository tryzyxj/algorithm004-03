## 一、关联式容器：map
　　map 作为一个关联式容器，它的所有元素类型都是`pair<const K, T>`，其中`pair`的第一个元素被视为**键值**（key），第二个元素被视为**实值**（value）。
### 1. map
- 在 map 中，不允许任何两个元素拥有相同的键值。
- map 底层由**红黑树**来实现，所以它的所有元素都会根据元素的键值自动被排序。

### 2. multimap
- 在 multimap 中，允许键值重复。
- multimap 底层由**红黑树**来实现，所以它的所有元素都会根据元素的键值自动被排序。

### 3. unordered_map
- 在 unordered_map 中，不允许任何两个元素拥有相同的键值。
- unordered_map 底层由**哈希表**来实现，所以在 unordered_map 中查找一个元素的平均时间复杂度为 `O(1)` 。

### 4. unordered_multimap
- 在 unordered_multimap 中，允许键值重复。
- unordered_multimap 底层由**哈希表**来实现，所以在 unordered_map 中查找一个元素的平均时间复杂度为 `O(1)` 。

## 二、关联式容器：set
　　set 作为一个关联式容器，它的元素不像 map 那样可以同时拥有键值（key）和实值（value），但是在 set 中元素的键值其实就是实值，而实值其实也是键值。
### 1. set
- 在 set 中，不允许任何两个元素拥有相同的键值。
- set 底层由**红黑树**来实现，所以它的所有元素都会根据元素的键值自动被排序。

### 2. multiset
- 在 multiset 中，允许键值重复。
- multiset 底层由**红黑树**来实现，所以它的所有元素都会根据元素的键值自动被排序。

### 3. unordered_set
- 在 unordered_set 中，不允许任何两个元素拥有相同的键值。
- unordered_set 底层由**哈希表**来实现，所以在 unordered_set 中查找一个元素的平均时间复杂度为 `O(1)` 。

### 4. unordered_multiset
- 在 unordered_multiset 中，允许键值重复。
- unordered_multiset 底层由**哈希表**来实现，所以在 unordered_set 中查找一个元素的平均时间复杂度为 `O(1)` 。

## 三、二叉树
### 1. 遍历方式
- 深度优先搜索
  - 先序遍历（根，左，右）
  - 中序遍历（左，根，右）
  - 后序遍历（左，右，根）
- 广度优先搜索
  - 层序遍历

### 2. 二叉搜索树
- 性质
  - 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；
  - 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉搜索树。
- 特点
  - 中序遍历一棵二叉搜索树，其结果是有序的。

## 四、递归
### 1. 思维要点
- 不要人肉进行递归（最大误区）
- 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
- 数学归纳法思维

### 2. 模板
> 第一步：递归终止条件<br>
> 第二步：处理当前层<br>
> 第三步：下探到下一层<br>
> 第四步：清理当前层的状态（可能需要）<br>

## 五、分治和回溯
　　分治和回溯本质上其实都是递归，只是在递归基础之上又做了一些不同的技术改进。
### 1. 分治
　　先将大问题划分为多个子问题，然后逐个解决每个子问题，最后再将所有子问题的结果进行合并，组成一个最终结果。
### 2. 回溯
　　在分步解决一个问题时，当尝试后发现现有的分步解法不能得到有效的正确的答案的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解法，再次尝试寻找问题的答案。
