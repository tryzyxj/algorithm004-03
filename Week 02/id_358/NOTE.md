# 第二周学习总结

## 本周第一课

学习了哈希表，映射，集合的基本实现和相关算法题

### 1. 哈希表，集合

哈希表实现中最重要的是哈希函数。数据量大时可能导致不同数据经过哈希函数得到相同的hash值，这叫做哈希碰撞。在工程实现上有通过“拉链表”的形式去解决相同key的问题。但如果这个拉出来的链表过长，就会退化到“链表”。

哈希表的结构特征是 key-value的形式。key不重复

set集合的结构特征是value不重复。

## 相关实战题解析

### 1. 有效的字母异位词

1. 暴力法

   先将字母排序，再比较。时间复杂度O(NlogN)

2. hashmap

   统计每个字母的频次再比较。进阶的方法是存每个字母的ASCII码

### 2. 两数之和

​	利用hashmap。枚举元素的同时，从map中找targe-a；

## 本周第二课

  学习了树，二叉树，二叉搜索树的基本结构和相关算法题

### 1. 树

三种遍历：

​	前序 ： 根 ---》左 ---》右

​	中序： 左 ---》根 ---》 右

​	后序： 左 ---》右 ---》根

> 树的相关算法题一般可以使用递归解决。因为1：不便于循环；2：树有自重复性的特征

### 2. 二叉搜索树

特点：

1. 左子树上节点值 < 根
2. 右子树上节点值 > 根
3. 左右子树也为二叉搜索树

> 二叉搜索树的中序遍历是升序排列。这在解决某些算法题时有用。

查询和操作都是O(logN)

> 删除：如果删除的是非叶子节点需要提大于删除的节点的第一个节点上去。

## 相关实战题解析

### 1. 二叉树的中序遍历

1. 递归
2. 通过栈。（使用两个while循环，先入栈左节点，然后出栈，访问根，访问右节点）

> 注意：递归不存在效率高低的问题。效率低是因为代码的问题，写成了“傻递归”。所以不要刻意规避递归			

## 本周第三课

学习了递归的实现，特性和思维要点

递归的代码模板

四个部分：1. 递归终止条件；2：处理当前逻辑；3：下探到下一层；4：清理当前层（如果有需要）；

本课重点介绍的关于递归的思维要点：

1. 不要人肉递归
2. 找到“最简最近”的方法；将问题拆解成可重复解决的问题（重复子问题）
3. 利用数学归纳法；比如爬楼梯，斐波那契；

### 相关实战题解析

### 1. 爬楼梯问题

解法是利用递归。不要用“傻递归”。可以优化，使用缓存。

还可以使用动态规划。

### 2. 括号生成问题

1. 把问题看成是往2 * n个格子里放括号。每个格子可以放左或右括号。关键是在放的过程中，验证括号的合法性。需满足：1）left括号可以随时加，但不能超标；2）right括号必须之前有left括号，且left 个数 > right个。 

### 3. 验证二叉搜索树

1. 中序遍历是有序的。

> 该问题需要注意的是左子树，右子树都是BST，容易写的时候忽略。

### 4. 二叉树的最大深度

比较简单，利用递归，深度遍历。O(N)

## 本周第四课

学习了分治，回溯的实现和特性

老师给出来分治代码模板。

1. Recursion terminator
2. prepare data
3. Conquer sub-problems
4. Processss and generate the final result
5. Reverse the current level states

> 回溯法近似于递归

## 相关实战题解析

### 1. 实现 pow(x, n)

1. 暴力法 。累乘
2. 分治法。分解子问题，使用递归解决。

思路：x^n ---> 2^10 ---> 2^5 * 2^5 ---> (2^2)*2

子问题： pow(x, n/2). 注意n < 0  的情况 （ 1/ pow(x, -n)）

merge: 

```
if n % 2 === 1
	then result = half * half * x;
else
	result = half * half
```

### 2. 子集

1. 递归。问题看成n个格子，每个元素选或不选。
2. 迭代。

### 3. 电话号码的字母组合

递归解决

#### 4. N皇后问题。

递归解决。

关键：循环column。使用set保存Col， pie，na 三条线上可以攻击的位置。









​					

