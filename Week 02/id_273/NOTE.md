# NOTE

### 第五课 哈希表、映射、集合的实现和特性

#### HashMap的特性：
1. 关于HashMap的特性以及源码分析放在了下面链接的博文中
2. 一般情况下, HashMap的使用场景大多都是基于KEY-VALUE的, 例如身份证号key对应一个公民对象value
* HashMap源码分析：https://blog.csdn.net/weixin_43624024/article/details/101975959

### 第六课 树、二叉树、二叉搜索树的实现和特性

#### 树的特性：
1. 大多数情况下, 树的数据结构都采用链表实现, 常见的二叉树就包含了left, right指针用于指向其左孩子/右孩子 

#### 二叉树的特性：
1. 二叉树在树的基础上，限制了每个结点只有left-child和right-child两个指针
2. 判断一个数据结构是图还是树，可以通过是否存在环来判断
3. 二叉树的遍历方式：前序遍历(根-左-右)、后序遍历(左-右-根)、中序遍历(左-根-右), 记忆二叉树的遍历递归实现非常重要
* 为什么二叉树的大部分问题都采用递归的方式解决：这是因为一个完整的二叉树又可以拆分为多个子树, 因为大部分问题中进行的操作大多都是针对树的重复操作, 所以树的问题一般都能用递归方式解决

#### 二叉搜索树的特性：
1. 在二叉树的基础之上，添加这么一个条件：root.left.val < root.val < root.right.val
2. 查询平均时间复杂度O(logN)，最坏情况下由树结构退化为链表结构, 复杂度降到O(n)
* BS-Tree源码分析：https://blog.csdn.net/weixin_43624024/article/details/101145066

### 第七课 递归的实现、特性、以及思维要点
1. 递归本质上有点类似于循环，可以把递归理解为通过函数体进行的循环
2. 递归必须包含：终止条件terminate、逻辑代码logic、递归调用drill down、（清理当前层clean）
3. 写递归时不要考虑人肉递归, 当前层只需要寻找问题的重复性并且考虑当前的逻辑即可, 这也是比较典型的自顶向下编程的思想
* 常见的一种对于递归的描述是：递归效率低下,不要在程序中使用递归。这是一种错误的说法, 虽然递归的可读性较差, 但是递归的效率取决于程序本身, 我们可以通过缓存或者动态规划对递归代码进行优化, 且递归方法的效率在不存在特别深的递归的情况下, 因为不需要开辟太多的方法栈, 效率也可视为和循环差不多

### 第八课 分治、回溯
1. 分治和回溯其实本质上还是递归, 可以将其理解为较为复杂的递归
2. 分治可以理解为把一个问题不断拆分成一个个的子问题,就像二叉树的结构,处理最底层的子问题返回结果给上层
3. 回溯可以理解为尝试获取所有可能的解决方案,若当前方案不通过则返回上层继续寻找下一个方案试错,典型的题目有八皇后问题

