# 第二周学习总结

## 哈希表、映射、集合

- 哈希表，也叫散列表，是根据关键码值即 `key-value` 而直接进行访问的数据结构，把关键码值通过`映射函数（散列函数 Hash Function）`映射到表中一个`位置（下标 Index）`来访问`记录（哈希表 散列表）`，以加快查找速度
- 哈希函数要避免产生哈希碰撞（不同的数据经过哈希函数计算后，得到相同的值）
- `拉链式解决冲突法` 即工程中常用的增加维度的办法，在相同下标位置使用一个链表来存储数据

## 树、二叉树、二叉搜索树

- 有根节点和子节点的二维数据结构
- 普通树查找内部节点需要全部遍历，时间复杂度为**O(n)**

### 二叉树

- 每个父节点的子节点只有两个
- Java 示例

    ```java
    public class TreeNode {
        public int val;
        public TreeNode left, right;
        public TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
    ```

- 二叉树遍历有三种
  - 前序遍历 `Pre-Order` 根节点 - 左 - 右
  - 中序遍历 `In-Order` 左 - 根节点 - 右
  - 前序遍历 `Post-Order` 左 - 右 - 根节点

### 二叉搜索树

- 也称二叉查找树、有序二叉树、排序二叉树
- 可能是一颗空树或者具有下列性质的二叉树
  - 左子树上`所有结点`的值均**小于**它的根结点的值
  - 右子树上`所有结点`的值均**大于**它的根结点的值
  - 左右子树也分别为二叉查找树（重复性）
- 中序遍历为升序排列
- 查询、插入、创建、删除都为**O(logn)**

### 与图的区别

- 树和图的最关键差别是看是否有`环`
- `LinkedList` 因为有两个 `next` 指针，可以看做特殊化的树
- `Tree` 是特殊化的 `Graph`，即没有环的图就是树

## 递归

- 通过函数体来进行的循环
- 写递归函数分为四个部分
  1. 写递归终止条件
  2. 处理当前层逻辑
  3. 下探到下一层
  4. 如果需要清理当前层
- Java 示例

    ```java
    public void recur(int level, int param) {
        // recursion terminator
        if (level > MAX_LEVEL) {
            // process result
            return;
        }

        // process logic in current level
        process(level, param);

        // drill down
        recur(level + 1, newParam);

        // restore current status
    }
    ```

- 递归要点
  - 尽量不要人肉进行递归
  - 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
  - 数学归纳法

## 分治

- 本质上是一种递归，将一个问题化解成多个子问题进行解决
- 分治的递归终止本质上就是递归层级到达最下层即子问题都解决（叶子节点不含任何子节点）
- 处理当前层逻辑时，把大问题分解成子问题

## 回溯

- 试错的思想，尝试分步的去解决一个问题
- 不断的在每一层去试，每一层有不同的方法
- 最坏的情况下，回溯法会导致一次复杂度为指数时间的计算

## 总结

- 依旧是找重复子的问题
- 递归解决问题是尽量不要去人肉递归
- 需要锻炼自己递归的思路，总是容易看见递归的方法就往里去想然后绕进去
- 回溯和分治还需要再去多回顾和练习
- 多看别人的解题思路
