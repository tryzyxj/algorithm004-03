# NOTE

###树相关
一，树

    树（Tree）是n（n≥0）个结点的有限集。在任意一棵非空树中：
    （1）有且仅有一个特定的被称为根（Root）的结点；
    （2）当n>1时，其余结点可分为m（m>0）个互不相交的有限集T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。
    结点的度（Degree）：结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶子（Leaf）或终端结点。度不为0的结点称为非终端结点或分支结点。
    树的度：是树内各结点的度的最大值。
    孩子和双亲：结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。
    结点的层次（Level）：是从根结点开始计算起，根为第一层，根的孩子为第二层，依次类推。树中结点的最大层次称为树的深度（Depth）或高度。
    如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。
    
    树有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根。
    每个节点可以有多个子节点(children)，而该节点是相应子节点的父节点(parent)。比如说，3,5是6的子节点，6是3,5的父节点；1,8,7是3的子节点, 3是1,8,7的父节点。树有一个没有父节点的节点，称为根节点(root)，如图中的6。没有子节点的节点称为叶节点(leaf)，比如图中的1,8,9,5节点。从图中还可以看到，上面的树总共有4个层次，6位于第一层，9位于第四层。树中节点的最大层次被称为深度。也就是说，该树的深度(depth)为4。

二，二叉树

    二叉树（Binary Tree）的特点是每个结点至多具有两棵子树（即在二叉树中不存在度大于2的结点），并且子树之间有左右之分。
    二叉树的性质：
    （1）、在二叉树的第i层上至多有2i-1个结点（i≥1）。
    （2）、深度为k的二叉树至多有2k-1个结点（k≥1）。
    （3）、对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

三，二叉查找树（左<中<右）

    我们从一种特殊的、使用很广泛的二叉树入手：二叉查找树。
    二叉查找树的性质：
    （1）、若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；
    （2）、若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；
    （3）、它的左、右子树也分别为二叉查找树。
    用一句话概括,二叉查找树的特点是，一个节点的左子节点的关键字值小于这个节点，右子节点的关键字值大于或等于这个父节点。

    二叉查找树的基本操作是查找，插入，删除，遍历，下面一一介绍：
    1，查找（search）
    我们已经知道，二叉搜索树的特点是左子节点小于父节点，右子节点大于或等于父节点。查找某个节点时，先从根节点入手，如果该元素值小于根节点，则转向左子节点，否则转向右子节点，以此类推，直到找到该节点，或者到最后一个叶子节点依然没有找到，则证明树中没有该节点
    2，插入（insert）
    插入一个新节点首先要确定插入的位置，关键思路是确定新节点父节点所在的位置。
    3，删除（delete）
    删除BST中的一个节点是最麻烦的操作，总结一下大概下面两种方法：
    Case 1：删除点没有左孩子，这是只需要将该节点的父节点和当前节点的有孩子相连即可
    Case2：删除点有左孩子.这种情况下先找到当前节点的左子树的最右节点，因为一个节点的左子树的最右节点也比右子树的最左节点小，把最右节点复制给删除点，然后删除最右节点


###递归

    递归，就是在运行的过程中调用自己。
    递归关系就是实体自己和自己建立关系。
构成递归需具备的条件：

    1. 子问题须与原始问题为同样的事，且更为简单；
    2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。
    
    在数学和计算机科学中，递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
    
    例如，下列为某人祖先的递归定义：
    某人的双亲是他的祖先（基本情况）。某人祖先的双亲同样是某人的祖先（递归步骤）。斐波纳契数列（Fibonacci Sequence），又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21..... I [1] 
    
    斐波纳契数列是典型的递归案例：
        Fib(0) = 1 [基本情况] Fib(1) = 1 [基本情况] 对所有n > 1的整数：Fib(n) = (Fib(n-1) + Fib(n-2)) [递归定义] 尽管有许多数学函数均可以递归表示，但在实际应用中，递归定义的高开销往往会让人望而却步。例如：
    阶乘（1) = 1 [基本情况] 对所有n > 1的整数：阶乘（n) = (n * 阶乘（n-1)) [递归定义] 一种便于理解的心理模型，是认为递归定义对对象的定义是按照“先前定义的”同类对象来定义的。例如：你怎样才能移动100个箱子？答案：你首先移动一个箱子，并记下它移动到的位置，然后再去解决较小的问题：你怎样才能移动99个箱子？最终，你的问题将变为怎样移动一个箱子，而这时你已经知道该怎么做的。
        
    如此的定义在数学中十分常见。例如，集合论对自然数的正式定义是：1是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。
    
    德罗斯特效应
    德罗斯特效应是递归的一种视觉形式。图中女性手持的物体中有一幅她本人手持同一物体的小图片，进而小图片中还有更小的一幅她手持同一物体的图片，依此类推。
    又例如，我们在两面相对的镜子之间放一根正在燃烧的蜡烛，我们会从其中一面镜子里看到一根蜡烛，蜡烛后面又有一面镜子，镜子里面又有一根蜡烛……这也是递归的表现。
    
####递归应用
    递归算法一般用于解决三类问题：
    (1)数据的定义是按递归定义的。（Fibonacci函数）
    (2)问题解法按递归算法实现。
    这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
    (3)数据的结构形式是按递归定义的。
    如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。
    
    递归的缺点：
    递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。
    递归典型问题： 梵塔问题（汉诺塔问题）