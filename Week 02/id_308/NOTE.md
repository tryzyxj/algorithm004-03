
## 哈希表、映射、集合的实现与特性


#### 哈希表 Hash Table

- 也叫散列表，是根据关键码值(key value)而直接进行访问的数据结构,它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度.
- 这个映射函数叫做散列函数，存放记录的数组叫做哈希表（散列表）
- 哈希碰撞：不同的key经过哈希函数有可能产生一个相同的数值，即此数值要存储多个数组，可以降其用链表连接，这种方法叫做拉链式解决冲突法
- 正常情况查询/添加/删除的时间复杂度：O(1)
- 最坏情况查询/添加/删除的时间复杂度: O(n)


## 树、二叉树、二叉搜索树的实现和特性

## 二叉树

- 树是二维结构
- 由根节点、子树组成
- 二叉树的子节点最多只有2个
- Linked List 是特殊化的Tree，Tree是特殊化的Graph 
- 二叉树遍历
    * 前序： 根-左-右
    * 中序： 左-根-右
    * 后序： 左-右-根
 
 
## 二叉搜索树 Binary Search Tree

- 二叉搜索树，也叫有序二叉树(Ordered Binary Tree)、排序二叉树(Sorted Binary Tree),是指一棵空树或者具有下列性质的二叉树：
    * 左子树上所有结点的值均小于它的根结点的值
    * 右子树上所有结点的值均大于它的根结点的值
    * 以此类推：左、右子树也分别为二叉查找树
- 中序遍历是升序遍历 
- 查询/插入的时间复杂度O(logN)


## 递归的实现、特性以及思维要点

- 树面试题解法一般都是递归的原因：
    * ① 树的结点和树本身数据结构的定义就是用递归的方式来进行的
    * ② 二叉树以及搜索二叉树,它在定义它数据结构和它算法特性的时候,也是有它的重复性，也就是自相似性
- 递归
    * 递归本质上就是循环，通过函数体来进行循环
- 代码模板
    * 递归终结条件
    * 处理当前逻辑
    * 下探到下一层
    * 清理当前层
- 思维要点
    * 抵制人肉递归
    * 找最近重复性
    * 数学归纳法思维

## 回溯的实现和特性

#### 分治 Divide & Conquer

- 分治也是一种递归,不过在它递归的过程中,把一个问题划分为好几个子问题
- 代码模板
    * terminator
    * process(split your big problem)
    * drill down(subproblmes)
    * reverse states

#### 回溯 Backtracking

- 回溯法采用试错的思想,它尝试分步的去解决一个问题.在分步解决问题的过程中,当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候,它将取消上一步甚至上几步的计算,再通过其他的可能的分步解答再次尝试寻找问题的答案.
- 回溯法通常用最简单的递归方法来实现,在反复重复上述步骤后可能出现2种情况
    * 找到一种可能存在的正确答案
    * 在尝试了所有可能的分步方法后宣告该方法没有解
- 在最坏的情况下,回溯法会导致一次复杂度为指数时间的计算
    
