# 【593-Week 02】第二周总结

## 复习

### 一维数据结构

- 单链表
- 数组
- 队列
- 栈

## 学习

### Hash Table

- 也叫散列表，是根据关键码值(Key value)而直接进行访问的数据结构
- Hash Function

  - 一个好的哈希函数就是逆天操作

    - 尽可能分散，使得元素均匀分布

  - 哈希碰撞

    - 解决办法

      - 拉链法

- 时间复杂度

  - access

    - a/n

  - insert

    - O(1)

  - delete

    - O(1)

  - search

    - O(1)

  - 最差情况

    - 都变成0(n)，退化成链表

- 实现过程

  - 输入

    - 哈希函数

      - 放置特定的位置

### Map

- key-value

  - key

    - A map cannot contain duplicate keys
    - each key can map to at most one value

- Java 源码分析

  - 基本操作

    - add
    - addAll
    - remove
    - clear
    - contains

  - TreeMap
  - HashMap

    - put
    - getNode

  - ConcurrentHashMap

- 工程实践

  - 通讯录
  - 用户信息表
  - 缓存
  - 键值对存储

### Set

- 规则

  - 不包含重复元素
  - 可以包含一些特殊的元素

    - null

- Java Set 源码分析

  - 基本操作

    - put
    - putAll
    - remove
    - keySet
    - entrySet
    - computeIfAbsent

      - 如果不存在，新建一个对象返回。

    - computeIfPresent

      - 如果存在，替换为新建的对象，如果没有新建的对象remove当前元素

  - TreeSet
  - HashSet

### Tree

- Basic Elements

  - Root
  - Level

    - from one

  - Node

    - Parent
    - Child

      - Left
      - Right

  - Sub-Tree

- Type

  - Binary Tree

    - Full
    - AVL
    - Black Red Tree
    - B+ Tree
    - Directory Tree
    - Binary Search Tree

      - query
      - insert
      - delete

- 遍历树的策略

  - 深度优先搜索（DFS）

    - Subtopic 4
    - Pre-Order
    - In-Order
    - Post-Order

  - 宽度优先搜索（BFS）

    - 逐层遍历

- traverse
- Linked List 是特殊化的 Tree
- 形成自己机械化的记忆

  - TreeNode的Java代码
  - 前中后序的遍历

    - 递归
    - 迭代

- 树的面试题解法一般都是递归，为什么？

  - 节点的定义
  - 重复性（自相似性）

### Graph

- type

  - Directed
  - Undirected

### Recursion

- 通过函数体进行循环
- Factorial
- 代码模板

  - terminator
  - process
  - drill down

    - 分治都话，这里可能是多个下层梦境，然后后面醒来上一层都时候不断合并结果

  - reverse if need 

- 细分

  - 回溯
  - 分治

    - 大问题找小问题和子问题

      - 重复性

    - 如何拆分子问题

      - 难点

- 思维要点

  - 不要人肉进行递归
  - 找到最近最简方法，将其拆解成可重复解决的问题(重复子问题)

    - 如果找出重复子问题?

      - 通过多个例子枚举找规律

    - 5行10行代码解决

  - 数学归纳法

### 实战题目

- 1. 两数之和

  - 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  - 限制条件

    - 不能重复利用同样的数据
    - 返回的是数组的下标

  - 本周次数

    - 1

      - Tue Oct 22 22:55:08 CST 2019
      - 什么时候会数组越界？

        - 数组index是从0开始的
        - 数组index超过数组的边界的时候
        - 例如，数组length为3，当你想访问[3]的时候会越界

      - Java 代码的包装类和基本类型的区别需要了解
      - 下次最好统计一下耗时

    

      - Tue Oct 24 22:55:08

- 49. 字母异位词分组

  - 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
  - 暴力法

    - 将数组内的单词，都进行排序，并且通过额外数组存储起来，

  - 本周次数

    - 1

      - Wed Oct 23 00:14:08 CST 2019
      - 默写两种解法

    

      - Wed Oct 23 10:08:12 CST 2019
      - 耗时约30min

42. 有效的字母异位词

  - 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
  - 思路

    - 也可以排序后，进行字符串对比

      - 时间复杂度
      - 空间复杂度

    - 统计字母出现的频次

      - 时间复杂度
      - 空间复杂度

  - 本周次数

    - 1
    

- 94. 二叉树的中序遍历

  - 给定一个二叉树，返回它的中序 遍历。
  - 思路

    - 递归

      - 思路很清晰

    - 迭代

      - 手动维护一个栈

    - 颜色标记法

  - 本周次数

    - 1

      - 通过手动维护栈的形式，并没有找到好理解的点

    

- 144. 二叉树的前序遍历

  - 给定一个二叉树，返回它的 前序 遍历。
  - 本周次数

    - 1

      - 递归相对比较容易编写

    

- 145. 二叉树的后序遍历

  - 给定一个二叉树，返回它的 后序 遍历。
  - 本周次数

    - 1

      - 递归相对比较容易编写
      - 前序的逆序就是后序的结果

    

- 590. N叉树的后序遍历

  - 给定一个 N 叉树，返回其节点值的后序遍历。
  - 本周次数

    - 1

      - 递归思路清晰
      - 先前序，后翻转结果；或者利用 链表不断再插入链表头

    

- 589. N叉树的前序遍历

  - 给定一个 N 叉树，返回其节点值的前序遍历。
  - 本周次数

    - 1

      - 前序遍历（根->左->右），利用栈，我们需要先根，因为栈是后进先出，所以我们需要将子结点从右到左入栈。

    

- 429. N叉树的层序遍历

  - 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。
  - 本周次数

    - 1
    

- 70. 爬楼梯

  - 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    注意：给定 n 是一个正整数。
  - mutual exclusive

    - 互斥

  - complete exclusive

    - 完全互斥

  - 本周次数

    - 1
    

2. 括号生成

  - 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
  - 本周次数

    - 1

      - 递归

        - 终止条件写错了，下次记得思路要想清楚才写

    

26. 翻转二叉树

  - 翻转一棵二叉树。
  - 本周次数

    - 1

      - 递归

        - 思路比较清晰，就是一路到底，然后翻转

    

- 98. 验证二叉搜索树

  - 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
    假设一个二叉搜索树具有如下特征：
    节点的左子树只包含小于当前节点的数。
    节点的右子树只包含大于当前节点的数。
    所有左子树和右子树自身必须也是二叉搜索树。
  - 本周次数

    - 1

      - 递归
      - 迭代方法需要多练习

    

- 104. 二叉树的最大深度

  - 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。
	- 本周次数

		- 1
		

- 111. 二叉树的最小深度

  - 给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。
	- 本周次数

		- 1
		

97. 二叉树的序列化与反序列化

  - 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
    请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
  - 本周次数

    - 1
    

- 169. 求众数

  - 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

		- 关键点
	
			- 次数大于 ⌊ n/2 ⌋ 的元素 == 众数
	
	- 本周次数
	
		- 1
		

- 17. 电话号码的字母组合

  - 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
    给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

    - 只有2-9的情况

  - 本周次数

    - 1

      - 基本功还是不扎实，还需多练习

    

- 51. N皇后

  - n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

    - 皇后的攻击范围：行，竖，撇，捺
    - 皇后的攻击范围的撇，捺如何计算，其实就是坐标轴的转换
    - 坐标

  - 本周次数

    - 1

    

## 总结

### 习惯

- clarification

  - 澄清说明

- possible solution -> optimal(space / time)

  - 通过各种分析，找出最优的

- code
- test case

  - 边界
  - 尽可能分散

### 学习总结

- 根据实际的时长来学习，不可能把所有的习题都做的滚瓜烂熟。

  - 课堂讲的题目，先做个烂熟
  - 课后题目，找几道觉得有意思的题目，来进行研究多种解法

### 下周计划

- 先复习
- 然后，根据上周的学习情况，进行本周的学习任务的优化

## 课后作业

### 236. 二叉树的最近公共祖先

- 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

- 本周次数

  - 1

    - 递归

      - 主要需要了解我们如何记录我能找到了p和q的结点，然后通过回溯，找到对应最近的祖先

  

### 105. 从前序与中序遍历序列构造二叉树

- 根据一棵树的前序遍历与中序遍历构造二叉树。

  - 你可以假设树中没有重复的元素。

- 本周次数

  - 1

    - 递归
    - 前序和后序的特点，寻找左右子树的位置

      - 前序遍历

        - 根->左->右

      - 中序遍历

        - 左->根->右

  

### 77. 组合

- 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
- 本周次数

  - 1

    - 递归

      - 回溯
      - 状态清空

    - 根据递归模版进行编码练习

  

### 46. 全排列

- 给定一个没有重复数字的序列，返回其所有可能的全排列。

  - 序列没有重复数字

- 本周次数

  - 1

    - 递归

      - 回溯
      - process

        - 增加限制条件使得每个梦境都不一样

    - 根据递归模版进行编码练习
