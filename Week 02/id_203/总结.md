### HashMap总结

对Java不熟，就不分析源码了，不过可以总结一下HashMap的实现原理，HashMap实现 `k,v` 的存储方式，底层是一个数组，在存入数据的时候，用Hash函数算出Key对应的下标，然后将元素放到数组的对应下标中。

在取出元素的时候，照样用同样的Hash函数算出Key的下标，然后到对应下标去取出元素即可，查找的时间复杂度是O(1)

但是会存在哈希碰撞的情况，即不同的Key经过Hash出来的下标是一样的，那么在同一个下标下的元素将会形成一个链表，取出数据的时候，在找到对应下标之后，还会去搜索链表，找到相应的key然后返回该元素，所以HashMap在最差的情况下，查找时间复杂度是O(n)

### 二叉树的遍历

前序遍历(preorder)：根->左->右
中序遍历(inorder)：左->根->右
后序遍历(postorder)：左->右->根

遍历顺序其实很好记，前中后序指的是根节点在子树的遍历位置，然后左节点一定在右节点前面，这样只要看根节点的位置就知道是那一种遍历顺序了

树的面试题解法一般都是用递归解决（为什么？）
- 结点和树本身的数据结构定义就是用递归的方式定义的
- 算法特性也是由所谓的重复性，即之前所说的最近重复子问题，二叉树都可以看出一个一个的子树构建起来的具有重复性

### 递归代码模板

1、递归的终止条件
2、处理当前层的逻辑
3、下探到下一层（递归）
4、有全局变量的话，需要清理当前层的状态

代码模板：
```cgo
public void recursion(int level, Object... params) {
  // 递归终止条件
  if (level > MAX_LEVEL) {
    // 逻辑处理
    return;
  }

  // 处理当前层的逻辑
  process(level, params);

  // 下探(递归)
  this.recursion(level + 1, params);
  
  // 有全局变量的话，需要清理当前层的状态
}
```

### 递归的思维要点

- 不要人肉递归（最大的误区）
- 找到最近最简的方法，将其拆解成可重复解决的问题
- 数学归纳法思维

### 分治&回溯

分治和回溯其实也是递归，分治是把一个大问题分解成各个小问题，然后合并结果，其代码模板跟递归的一样，只是在下探一层之后再加一个合并结果

