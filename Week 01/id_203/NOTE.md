# NOTE

### 移动零

原本老师课中所讲的代码，在每次循环中碰到非0的数就将 `i` 下标中的数赋值给 `j` 下标的位置，但我后面思考了一下，只有在 `i` 和 `j` 不相等，即两个指针的指向位置不同的时候，才需要执行这个操作，所以稍微做了一点修改，将这个赋值语句挪进判断内，如下

```
func moveZeroes(nums []int) {
	j := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			if i != j {
				nums[j] = nums[i] //将这个语句挪进来了
				nums[i] = 0
			}
			j++
		}
	}

}
```

### 加一

这题的解题思路只看了别人的一半，受到了启发，自己把后面的步骤补充出来，跟原来的算法不太一样，LeetCode上运行是 0ms，时间复杂度是 O(n)，我的算法是

- 从数组的最后一个元素往前循环，如果碰到的值是 `9` 这将当前的元素置 `0` ，然后进入下一个循环
- 如果碰到非 `9` 的元素，则把当前的元素加 `1` ，跳出循环
- 判断数组的第一个元素(即下标为0的元素)是否大于0，如果大于0则说明没有进位，直接返回这个数组即可
- 如果第一个元素为 `0` 则说明，原数组是 `9999...`，此时需要进位，而此时的数组里面元素全是 `0`，这时只要创建一个里面只包含一个元素 `1` 的数组，然后拼接上这个全是0的数组即可

```
func plusOne(digits []int) []int {
    for i := len(digits) - 1; i >= 0; i-- {
        if digits[i] == 9 {
            digits[i] = 0
        } else {
            digits[i] ++
            break
        }
    }
    
    if digits[0] > 0 {
        return digits
    }
    
    return append([]int{1}, digits...)
}
```

### 设计循环链表

这题没有看题解，其实没有涉及到复杂的算法，这题的感觉就是老师所说的自顶向下的设计，主干方法都定义好了，自己填上内容，慢慢debug做出来，在debug过程中注意到以前没有注意到的细节

采用双端链表，head 和 end 指针分别指向队头和队尾，队列的插入删除时间复杂度都是O(1)，我那个解法在golang中运行16ms，速度超过90%左右的人