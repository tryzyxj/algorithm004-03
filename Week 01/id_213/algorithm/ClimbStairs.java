class Solution {
//这是个题目用递归的思量来做
//  要点：1.寻找重复的动作。可以从前面找，也可以从后面找。
//  该题从后面开始从前面开始可以找到斐波拉契函数的规律。
//  从后面可以找到最后一阶可以由前面一阶迈一步，前面俩阶迈两步这种方式。
//  而前面一阶又可以分为…………
//  实现：该方法的实现比递归调用好的点是不会出现栈溢出。
//  通过循环赋值的方式减小了对栈的压力。

    public int climbStairs(int n) {
        if(n <= 2 ) return n;
        int s1 = 1;
        int s2 = 2;
        int s3 = 0;
        for(int i = 3; i <= n; i++) {
            s3 = s2 + s1;
            s1 = s2;
            s2 = s3;
            
        }
        return s3;
    }
}