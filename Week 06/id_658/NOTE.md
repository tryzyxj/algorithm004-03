# 第六周学习总结

## 字典树 Trie

### 基本结构

- 又称单词查找树或键树，是一种树形结构，多叉树
- 典型的应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计
- 最大限度地减少无谓的字符串比较，查询效率比哈希表高

### 基本性质

- 结点本身不存完整单词
- 从根结点到某一结点，路径上经过的字符连接起来即为该结点对应的字符串
- 每个结点的所有子结点路径代表的字符都不相同

### 核心思想

- Trie 树的核心思想是空间换时间
- 利用字符串的公共前缀来降低查询时间的开销已达到提高效率的目的

## 并查集 Disjoint Set

- 解决 `组团、配对` 场景的问题
- 判断两个个体是否在一个集合中 / 两个群组是不是一个群组，合并群组

### 基本操作

- 解决问题主要要实现的三个函数
- makeSet(s): 建立一个新的并查集，其中包含 s 个单元素集合
- unionSet(x,y): 把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并
- find(x): 找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了

### 实现

```java
class UnionFind {
    private int count = 0;
    private int[] parent;

    public UnionFind(int n) {
        count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        count--;
    }
}
```

## 高级搜索

### 初级搜索

- 朴素搜索
- 深度优先搜索 `DFS: depth first search`
- 广度优先搜索 `BFS: breadth first search`

#### 优化方式

- 不重复（fibonacci）、剪枝（生成括号问题）
  - 当状态树的一个分支没有必要的时候就去掉不进行搜索
  - 不必要性来自重复或者分支为次优（找最优解时）
- 双向搜索、启发式搜索

### 双向 BFS

- 从两端开始 BFS 中间重合的结点就是两端之间的最短路径

### 启发式搜索 Heuristic Search (A*)

- 本质上通过优先级不断地去搜索

#### 估价函数

- 启发式函数：h(n) 用来评价哪些结点最有希望是一个我们要找的结点，h(n) 会返回一个非负实数，也可以认为是从结点 n 到目标结点路径的估计成本
- 启发式函数是一种告知搜索方向的方法，它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标

## 红黑树和 AVL 树

- 近似平衡二叉树，左右子树高度尽量是平衡的，并且左右子树以此类推下去都尽量是平衡的

### AVL树

- 平衡因子 Balance Factor : 左子树的**高度**减去右子树的**高度**（有时相反）
  - balance factor 取值 {-1, 0, -1}
  - 高度：查询二叉搜索树的效率只与高度有关
- 通过旋转操作来进行平衡（四种）
  - 左旋 右右子树
  - 右旋 左左子树
  - 左右旋 左右子树 先左旋再右旋
  - 右左旋 右左子树 先右旋再左旋
- 不足：结点需要存储额外信息、且调整次数频繁

### 红黑树

- 是一种**近似平衡**的二叉搜索树，它能够确保任何一个结点的左右子树的**高度差小于两倍**（大的高度是小的高度的两倍）
- 每个结点要么是红色，要么是黑色
- 根结点是黑色
- 每个 叶结点（NIL 结点，空结点）是黑色的
- 不能有相邻接的两个红色结点
- 从任一结点到其每个叶子结点的所有路径都包含相同数目的黑色结点

### 对比

- AVL 树因为更加严格的平衡，所以比红黑树提供了更快的查找
- 红黑树提供了更快的插入和删除操作，因为 AVL 树的旋转操作比较多
- 因为 AVL 树需要存储的额外信息（factors or heights）更多一些，所以需要更多的内存，而红黑树只需要 `1 bit` 来存储0或1表示黑或者红
- 读操作比较多、写操作比较少的场景下用 AVL 树，例如 databases
- 红黑树用在一些语言库中的 map set 中
