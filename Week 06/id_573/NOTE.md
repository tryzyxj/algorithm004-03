# NOTE

  
### Trie
Trie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 O(n)O(n)，其中 nn 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 O(m)O(m) 的时间复杂度，其中 mm 为键长。而在平衡树中查找键值需要 O(m \log n)O(mlogn) 时间复杂度。

### 作用
Trie (发音为 "try") 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用：
    
    1. 自动补全
    2. 拼写检查
    3. IP 路由 (最长前缀匹配)
    4. T9 (九宫格) 打字预测
    5. 单词游戏
    6. 还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 Trie 树呢？尽管哈希表可以在 O(1)O(1) 时间内寻找键值，却无法高效的完成以下操作：
        找到具有同一前缀的全部键值。
        按词典序枚举字符串的数据集。


### Trie 树的结点结构

    Trie 树是一个有根的树，其结点具有以下字段：
    
````
    1、最多 RR 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。本文中假定 RR 为 26，小写拉丁字母的数量。
    2、布尔字段，以指定节点是对应键的结尾还是只是键前缀。
````
    
### Trie 树中最常见的两个操作是键的插入和查找。
    
    向 Trie 树中插入键
    我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：
    
    链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。
    链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。
    重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。
    
### 复杂度分析
  
    时间复杂度：O(m)O(m)，其中 mm 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 mm 次操作。
    空间复杂度：O(m)O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 mm 个结点，使用 O(m)O(m) 空间。
  
#### 在 Trie 树中查找键
    每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：
  
    存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。
    不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :
    还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。
    没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。
  
#### 查找 Trie 树中的键前缀
    该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “isend” 标记，因为我们搜索的是键的前缀，而不是整个键。
  
  
### DFS\BFS

    DFS即深度优先搜索，俗称不撞南墙不回头，实现方式是用栈来保存选择，然后每次取栈顶元素，并且依据栈顶元素遍历，将符合条件的元素压栈，然后如此往复。

    BFS即广度优先搜索，特征是层次遍历，利用队列来实现。每次取队列队首元素，遍历所有节点，将所有符合条件的元素入队。循环往复。

    不管是DFS还是BFS，都需要一个状态标记来表示元素已经被选取，避免出现重复选择以及死循环。

    从上面的分析，我们可以知道DFS是很适合去做连通性搜索测试，并且如果不需要找到最短路径的话，可以直接退出，不需要存储大量路径信息（C语言也可以用递归来做）；而BFS则是很适合去搜索==最短路径==，因为其会进行层次遍历，在任何一层发现了目标，那都是最短的路径上发现的。但是BFS会要求记录每一层的信息，会导致信息记录量大。（而且C语言没有队列，需要额外实现）

    但是很明显，我们这道题就是需要用到BFS。也即根据beginWord来搜索所有与其相差仅为1个词语的单词，将其放入队列中，然后后循环搜索。不过要注意的是，存粹的BFS会超时，所以需要双端BFS，也就是从beginWord和endWord两端搜索。


### 双端BFS


依据名字，我们要从两端都搜索，也就需要两个队列来保存各自的搜索信息。我们记为begin_word_queue和end_word_queue，并且记为A和B。双端搜索的规则如下：

1、每次选取A和B中最少元素的来进行出队操作。如果size相等，取A中元素。

2、每次遍历到符合要求的元素，则进行入队操作，A搜索到的记为1， B搜索到的记为2。但是赋值方式为：
    
    
    int selected_flag; //0 means A; 1 means B
    int flag = 0;
    flag |= selected_flag;
    
3、当flag为3的时候代表A、B同时访问了一个节点，退出。

4、记录访问层次的次数，返回此次数。层次次数初始值为1
    
   
    
为什么这么做呢？因为BFS是层次遍历，也就是金字塔型遍历，越往后，搜索到的节点越多，信息越庞大，导致搜索时间越长。==但是结束点又只有一个，所以数据量大就会超时==。
    