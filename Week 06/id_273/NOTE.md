# NOTE

### 第十三课 字典树和并查集

#### Tire树的基本实现和特性
使用场景：
1. 搜索引擎中, 只输入前缀词就可以根据热度从上至下显示出候选词, 采用了字典树 + 优先队列的数据结构

基本性质：
1. 节点数组本身不存完整单词, 如果不区分大小写的话, 节点数组大小为26
2. 从根节点到某一个节点, 路径上经过的字符连接起来, 为该结点对应的字符串

核心思想：
1. 空间换时间
2. 因为Trie树本身的数据结构性质, 它一般用于解决通过前缀词搜索候选词的问题

#### 并查集的基本实现和特性
使用场景：
1. 一般用于在联通图中, 判断是否联通且合并相互联通的两个图结构

实现框架：
1. makeSet(s)：初始化一个并查集, 一般通过数组实现, 其中包含s个单元素集合
2. unionSet(x, y)：将元素x, y所在的集合合并, 要求两集合不相交
3. find(x)：找到元素x所在集合的头节点, 该操作也可判断两个元素是否位于同一个集合中, 只需要判断两个元素的头节点是否相同

### 第十四课 高级搜索

#### 剪枝的实现和特性
1. 一般对于朴素搜索的优化方式可以通过："剪枝次优解" 和 "剪枝重复解" 的方式来进行优化
2. 我们可以大体将搜索的方式分为DFS和BFS
3. 比较形象的理解DFS剪枝的实现可以参考斐波那契问题, 用最简单的暴力递归那么递归的状态树是指数级别的, 其中很多棵状态树都涉及到了重复的计算, 那么为了避免这些不必要的计算, 我们可以将那些重复的状态树进行剪枝, 以达到性能优化的目的
3. 那么对于BFS的枝减一般可以通过双向BFS和启发式搜索来实现

#### 双向BFS的实现和特性
1. 对于单向的BFS最坏情况下, 要扩散到最深的那一层才能够获取到结果, 而基于BFS的特性, 	每扩散一层性能消耗都是成倍增加的, 可以理解为BFS扩散得越深, 开支越大
2. 那么为了提高BFS的性能, 可以基于上述BFS的特性进行优化, 也就是采用双端BFS。这样两端一起扩散的成本要小于一端扩散的成本

#### 启发式搜索的实现和特性
1. 普通的BFS必须要遍历所有的状态树才能够获取到最后的结果, 那么除了双向BFS能够对其进行优化, 还可以通过启发式搜索
2. 启发式搜索采用优先队列, 入队的每个状态节点包含了优先级, 也就是距离result节点的距离长短, 那么每当出队操作的时候, 都优先poll距离result节点最短的节点, 就可以剪枝掉其他次优的状态树

### 第十五课 红黑树和AVL
#### AVL
1. 由于二叉搜索树在某些极端情况下可能退化到链表结构导致查询时间复杂度退化到O(N), 因此引入的AVL
2. AVL限制了所有节点的左右子树深度不超过2, 因此它的查询时间复杂度始终为O(log2N)
3. 这个限制左右的深度实现主要是通过了"旋转", 旋转主要分为4种情况, 具体就不赘述了, 也就是AVL每次进行插入和删除操作时, 若发现某个节点不平衡, 就会进行一次旋转操作
4. 因此, 平衡二叉树更加适用于增删操作较少, 查询较多的场景


### 红黑树
1. 红黑树是一种近似平衡二叉树, 它在AVL的基础之上妥协了一些规定, 以至于红黑树相较于AVL, 插入和删除操作的开支要更加小
2. 红黑树限制了所有节点的左右子树深度不超过2倍
3. 红黑树的每个节点要么是红色, 要么是黑色
4. 根节点与叶子节点为黑色
5. 不能有邻接的两个红色节点
6. 从任意节点至其叶子节点的所有路径都包含相同数目的黑色节点 